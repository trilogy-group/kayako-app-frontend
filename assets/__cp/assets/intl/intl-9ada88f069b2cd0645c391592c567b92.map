{"version":3,"sources":["/src/cldr.js","/src/core.js","/src/exp.js","/src/main.js"],"names":["$$cldr$$isDateFormatOnly","obj","i","$$cldr$$tmKeys","length","hasOwnProperty","$$cldr$$isTimeFormatOnly","$$cldr$$dtKeys","$$cldr$$joinDateAndTimeFormats","dateFormatObj","timeFormatObj","o","j","$$cldr$$computeFinalPatterns","formatObj","pattern12","extendedPattern","replace","$0","literal","pattern","$$cldr$$expPatternTrimmer","$$cldr$$createDateTimeFormat","skeleton","$$cldr$$unwantedDTCs","test","originalPattern","$$cldr$$expDTComponents","charAt","era","year","quarter","month","week","day","weekday","undefined","hour12","hour","minute","second","timeZoneName","$$cldr$$createDateTimeFormats","formats","computed","availableFormats","timeFormats","dateFormats","result","timeRelatedFormats","dateRelatedFormats","push","full","medium","$$core$$IsStructurallyValidLanguageTag","locale","$$exp$$expBCP47Syntax","$$exp$$expVariantDupes","$$exp$$expSingletonDupes","$$core$$CanonicalizeLanguageTag","match","parts","toLowerCase","split","max","toUpperCase","slice","$$core$$arrJoin","call","$$exp$$expExtSequences","sort","RegExp","source","$$core$$hop","$$core$$redundantTags","tags","subtags","extLang","$$core$$arrSlice","$$core$$DefaultLocale","$$core$$defaultLocale","$$core$$IsWellFormedCurrencyCode","currency","c","String","normalized","$$core$$toLatinUpperCase","$$core$$expCurrencyCode","$$core$$CanonicalizeLocaleList","locales","$$core$$List","seen","O","$$core$$toObject","len","k","Pk","kPresent","kValue","TypeError","tag","RangeError","$$core$$arrIndexOf","$$core$$BestAvailableLocale","availableLocales","candidate","pos","lastIndexOf","substring","$$core$$LookupMatcher","requestedLocales","availableLocale","noExtensionsLocale","$$core$$expUnicodeExSeq","$$core$$Record","extension","extensionIndex","indexOf","$$core$$BestFitMatcher","$$core$$ResolveLocale","options","relevantExtensionKeys","localeData","ReferenceError","matcher","r","foundLocale","prototype","extensionSubtags","extensionSubtagsLength","supportedExtension","key","foundLocaleData","keyLocaleData","value","supportedExtensionAddition","keyPos","requestedValue","valuePos","optionsValue","preExtension","postExtension","$$core$$LookupSupportedLocales","subset","subsetArray","$$core$$BestFitSupportedLocales","$$core$$SupportedLocales","localeMatcher","P","writable","configurable","$$core$$GetOption","property","type","values","fallback","Boolean","$$core$$GetNumberOption","minimum","maximum","Number","isNaN","Math","floor","$$core$$NumberFormatConstructor","arguments","this","$$core$$Intl","$$core$$InitializeNumberFormat","NumberFormat","numberFormat","internal","$$core$$getInternalProperties","regexpState","$$core$$createRegExpRestore","$$core$$secret","opt","$$core$$internals","dataLocale","s","cDigits","$$core$$CurrencyDigits","cd","mnid","mnfdDefault","mnfd","mxfdDefault","mxfd","mnsd","minimumSignificantDigits","mxsd","maximumSignificantDigits","g","dataLocaleData","patterns","stylePatterns","positivePattern","negativePattern","$$core$$es3","format","$$core$$GetFormatNumber","exp","input","$$core$$currencyMinorUnits","F","$$core$$FormatNumber","bf","$$core$$fnBind","x","n","nums","data","ild","symbols","latn","negative","isFinite","nan","infinity","$$core$$ToRawPrecision","$$core$$ToRawFixed","$$core$$numSys","digits","digit","decimal","igr","pgSize","primaryGroupSize","sgSize","secondaryGroupSize","groups","end","idx","start","group","cData","currencies","minPrecision","maxPrecision","p","m","Array","e","$$core$$log10Floor","abs","f","round","LN10","cut","minInteger","minFraction","maxFraction","toFixed","z","$$core$$DateTimeFormatConstructor","$$core$$InitializeDateTimeFormat","DateTimeFormat","dateTimeFormat","$$core$$ToDateTimeOptions","tz","timeZone","prop","$$core$$dateTimeComponents","bestFormat","$$core$$ToDateTimeFormats","$$core$$BasicFormatMatcher","$$core$$BestFitFormatMatcher","hr12","hourNo0","$$core$$GetFormatDateTime","Object","toString","required","defaults","opt2","create","$$core$$objCreate","needDefaults","$$core$$calculateScore","bestFit","diffDataTypePenalty","removalPenalty","additionPenalty","longLessPenalty","longMorePenalty","shortLessPenalty","shortMorePenalty","bestScore","Infinity","score","optionsProp","formatProp","optionsPropIndex","formatPropIndex","delta","min","Date","now","$$core$$FormatDateTime","__getInternalProperties","nf","useGrouping","nf2","minimumIntegerDigits","tm","$$core$$ToLocalTime","calendars","ca","pm","fv","v","$$core$$dateWidths","$$core$$resolveDateString","Error","date","calendar","d","[[weekday]]","[[era]]","[[year]]","[[month]]","[[day]]","[[hour]]","[[minute]]","[[second]]","[[inDST]]","$$core$$addLocaleData","number","$$core$$arrShift","nu","$$core$$numberFormatProtoInitialised","$$core$$dateTimeFormatProtoInitialised","log10","log","LOG10E","$$core$$supportedLocalesOf","component","width","gregory","alts","narrow","short","long","resolved","enumerable","apply","esc","lm","lastMatch","ml","multiline","ret","reg","has","cap","str","ch","arg","$$exp$$extlang","$$exp$$singleton","$$exp$$irregular","$$exp$$regular","$$exp$$language","$$exp$$script","$$exp$$region","$$exp$$variant","$$exp$$extension","$$exp$$privateuse","$$exp$$langtag","$$exp$$grandfathered","sentinel","defineProperty","$$core$$realDefineProp","__defineGetter__","name","desc","get","search","t","proto","props","concat","join","shift","unshift","Function","bind","thisObj","fn","args","a","$$core$$arrConcat","random","art-lojban","i-ami","i-bnn","i-hak","i-klingon","i-lux","i-navajo","i-pwn","i-tao","i-tay","i-tsu","no-bok","no-nyn","sgn-BE-FR","sgn-BE-NL","sgn-CH-DE","zh-guoyu","zh-hakka","zh-min-nan","zh-xiang","sgn-BR","sgn-CO","sgn-DE","sgn-DK","sgn-ES","sgn-FR","sgn-GB","sgn-GR","sgn-IE","sgn-IT","sgn-JP","sgn-MX","sgn-NI","sgn-NL","sgn-NO","sgn-PT","sgn-SE","sgn-US","sgn-ZA","zh-cmn","zh-cmn-Hans","zh-cmn-Hant","zh-gan","zh-wuu","zh-yue","BU","DD","FX","TP","YD","ZR","heploc","in","iw","ji","jw","mo","ayx","bjd","ccq","cjr","cka","cmk","drh","drw","gav","hrr","ibi","kgh","lcq","mst","myt","sca","tie","tkk","tlw","tnf","ybd","yma","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","aed","aen","afb","afg","ajp","apc","apd","arb","arq","ars","ary","arz","ase","asf","asp","asq","asw","auz","avl","ayh","ayl","ayn","ayp","bbz","bfi","bfk","bjn","bog","bqn","bqy","btj","bve","bvl","bvu","bzs","cdo","cds","cjy","cmn","coa","cpx","csc","csd","cse","csf","csg","csl","csn","csq","csr","czh","czo","doq","dse","dsl","dup","ecs","esl","esn","eso","eth","fcs","fse","fsl","fss","gan","gds","gom","gse","gsg","gsm","gss","gus","hab","haf","hak","hds","hji","hks","hos","hps","hsh","hsl","hsn","icl","ils","inl","ins","ise","isg","isr","jak","jax","jcs","jhs","jls","jos","jsl","jus","kgi","knn","kvb","kvk","kvr","kxd","lbs","lce","lcf","liw","lls","lsg","lsl","lso","lsp","lst","lsy","ltg","lvs","lzh","mdl","meo","mfa","mfb","mfs","mnp","mqg","mre","msd","msi","msr","mui","mzc","mzg","mzy","nbs","ncs","nsi","nsl","nsp","nsr","nzs","okl","orn","ors","pel","pga","pks","prl","prz","psc","psd","pse","psg","psl","pso","psp","psr","pys","rms","rsi","rsl","sdl","sfb","sfs","sgg","sgx","shu","slf","sls","sqk","sqs","ssh","ssp","ssr","svk","swc","swh","swl","syy","tmw","tse","tsm","tsq","tss","tsy","tza","ugn","ugy","ukl","uks","urk","uzn","uzs","vgt","vkk","vkt","vsi","vsl","vsv","wuu","xki","xml","xmm","xms","yds","ysl","yue","zib","zlm","zmi","zsl","zsm","BHD","BYR","XOF","BIF","XAF","CLF","CLP","KMF","DJF","XPF","GNF","ISK","IQD","JPY","JOD","KRW","KWD","LYD","OMR","PYG","RWF","TND","UGX","UYI","VUV","VND","[[availableLocales]]","[[relevantExtensionKeys]]","[[localeData]]","arab","arabext","bali","beng","deva","fullwide","gujr","guru","hanidec","khmr","knda","laoo","limb","mlym","mong","mymr","orya","tamldec","telu","thai","tibt","descs","$$core$$ls","__localeSensitiveProtos","toLocaleString","toLocaleDateString","toLocaleTimeString","Intl","$$core$$default","__applyLocaleSensitivePrototypes"],"mappings":"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AAO,MAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,MAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,MAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,OAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,MAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAA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","file":"intl.js","sourcesContent":["/* jshint esnext: true, laxbreak:true */\n\n/**\n* Defines regular expressions for various operations related to the BCP 47 syntax,\n* as defined at http://tools.ietf.org/html/bcp47#section-2.1\n*/\n\nvar\n    // extlang       = 3ALPHA              ; selected ISO 639 codes\n    //                 *2(\"-\" 3ALPHA)      ; permanently reserved\n    extlang = '[a-z]{3}(?:-[a-z]{3}){0,2}',\n\n    // language      = 2*3ALPHA            ; shortest ISO 639 code\n    //                 [\"-\" extlang]       ; sometimes followed by\n    //                                     ; extended language subtags\n    //               / 4ALPHA              ; or reserved for future use\n    //               / 5*8ALPHA            ; or registered language subtag\n    language = '(?:[a-z]{2,3}(?:-' + extlang + ')?|[a-z]{4}|[a-z]{5,8})',\n\n    // script        = 4ALPHA              ; ISO 15924 code\n    script = '[a-z]{4}',\n\n    // region        = 2ALPHA              ; ISO 3166-1 code\n    //               / 3DIGIT              ; UN M.49 code\n    region = '(?:[a-z]{2}|\\\\d{3})',\n\n    // variant       = 5*8alphanum         ; registered variants\n    //               / (DIGIT 3alphanum)\n    variant = '(?:[a-z0-9]{5,8}|\\\\d[a-z0-9]{3})',\n\n    //                                     ; Single alphanumerics\n    //                                     ; \"x\" reserved for private use\n    // singleton     = DIGIT               ; 0 - 9\n    //               / %x41-57             ; A - W\n    //               / %x59-5A             ; Y - Z\n    //               / %x61-77             ; a - w\n    //               / %x79-7A             ; y - z\n    singleton = '[0-9a-wy-z]',\n\n    // extension     = singleton 1*(\"-\" (2*8alphanum))\n    extension = singleton + '(?:-[a-z0-9]{2,8})+',\n\n    // privateuse    = \"x\" 1*(\"-\" (1*8alphanum))\n    privateuse = 'x(?:-[a-z0-9]{1,8})+',\n\n    // irregular     = \"en-GB-oed\"         ; irregular tags do not match\n    //               / \"i-ami\"             ; the 'langtag' production and\n    //               / \"i-bnn\"             ; would not otherwise be\n    //               / \"i-default\"         ; considered 'well-formed'\n    //               / \"i-enochian\"        ; These tags are all valid,\n    //               / \"i-hak\"             ; but most are deprecated\n    //               / \"i-klingon\"         ; in favor of more modern\n    //               / \"i-lux\"             ; subtags or subtag\n    //               / \"i-mingo\"           ; combination\n    //               / \"i-navajo\"\n    //               / \"i-pwn\"\n    //               / \"i-tao\"\n    //               / \"i-tay\"\n    //               / \"i-tsu\"\n    //               / \"sgn-BE-FR\"\n    //               / \"sgn-BE-NL\"\n    //               / \"sgn-CH-DE\"\n    irregular = '(?:en-GB-oed'\n              + '|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)'\n              + '|sgn-(?:BE-FR|BE-NL|CH-DE))',\n\n    // regular       = \"art-lojban\"        ; these tags match the 'langtag'\n    //               / \"cel-gaulish\"       ; production, but their subtags\n    //               / \"no-bok\"            ; are not extended language\n    //               / \"no-nyn\"            ; or variant subtags: their meaning\n    //               / \"zh-guoyu\"          ; is defined by their registration\n    //               / \"zh-hakka\"          ; and all of these are deprecated\n    //               / \"zh-min\"            ; in favor of a more modern\n    //               / \"zh-min-nan\"        ; subtag or sequence of subtags\n    //               / \"zh-xiang\"\n    regular = '(?:art-lojban|cel-gaulish|no-bok|no-nyn'\n            + '|zh-(?:guoyu|hakka|min|min-nan|xiang))',\n\n    // grandfathered = irregular           ; non-redundant tags registered\n    //               / regular             ; during the RFC 3066 era\n    grandfathered = '(?:' + irregular + '|' + regular + ')',\n\n    // langtag       = language\n    //                 [\"-\" script]\n    //                 [\"-\" region]\n    //                 *(\"-\" variant)\n    //                 *(\"-\" extension)\n    //                 [\"-\" privateuse]\n    langtag = language + '(?:-' + script + ')?(?:-' + region + ')?(?:-'\n            + variant + ')*(?:-' + extension + ')*(?:-' + privateuse + ')?';\n\n// Language-Tag  = langtag             ; normal language tags\n//               / privateuse          ; private use tag\n//               / grandfathered       ; grandfathered tags\nexport var expBCP47Syntax = RegExp('^(?:'+langtag+'|'+privateuse+'|'+grandfathered+')$', 'i');\n\n// Match duplicate variants in a language tag\nexport var expVariantDupes = RegExp('^(?!x).*?-('+variant+')-(?:\\\\w{4,8}-(?!x-))*\\\\1\\\\b', 'i');\n\n// Match duplicate singletons in a language tag (except in private use)\nexport var expSingletonDupes = RegExp('^(?!x).*?-('+singleton+')-(?:\\\\w+-(?!x-))*\\\\1\\\\b', 'i');\n\n// Match all extension sequences\nexport var expExtSequences = RegExp('-'+extension, 'ig');\n","/* jslint esnext: true */\n\n// Match these datetime components in a CLDR pattern, except those in single quotes\nvar expDTComponents = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;\n// trim patterns after transformations\nvar expPatternTrimmer = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n// Skip over patterns with these datetime components because we don't have data\n// to back them up:\n// timezone, weekday, amoung others\nvar unwantedDTCs = /[rqQxXVOvZASjJgwWIQq]/;\n\nvar dtKeys = [\"weekday\", \"era\", \"year\", \"month\", \"day\", \"weekday\", \"quarter\"];\nvar tmKeys = [\"hour\", \"minute\", \"second\", \"hour12\", \"timeZoneName\"];\n\nfunction isDateFormatOnly(obj) {\n    for (var i = 0; i < tmKeys.length; i += 1) {\n        if (obj.hasOwnProperty(tmKeys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isTimeFormatOnly(obj) {\n    for (var i = 0; i < dtKeys.length; i += 1) {\n        if (obj.hasOwnProperty(dtKeys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction joinDateAndTimeFormats(dateFormatObj, timeFormatObj) {\n    var o = {};\n    for (var i = 0; i < dtKeys.length; i += 1) {\n        if (dateFormatObj[dtKeys[i]]) {\n            o[dtKeys[i]] = dateFormatObj[dtKeys[i]];\n        }\n    }\n    for (var j = 0; j < tmKeys.length; j += 1) {\n        if (timeFormatObj[tmKeys[j]]) {\n            o[tmKeys[j]] = timeFormatObj[tmKeys[j]];\n        }\n    }\n    return o;\n}\n\nfunction computeFinalPatterns(formatObj) {\n    // From http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns:\n    //  'In patterns, two single quotes represents a literal single quote, either\n    //   inside or outside single quotes. Text within single quotes is not\n    //   interpreted in any way (except for two adjacent single quotes).'\n    formatObj.pattern12 = formatObj.extendedPattern.replace(/'([^']*)'/g, function ($0, literal) {\n        return literal ? literal : \"'\";\n    });\n\n    // pattern 12 is always the default. we can produce the 24 by removing {ampm}\n    formatObj.pattern = formatObj.pattern12.replace('{ampm}', '').replace(expPatternTrimmer, '');\n    return formatObj;\n}\n\n/**\n * Converts the CLDR availableFormats into the objects and patterns required by\n * the ECMAScript Internationalization API specification.\n */\nexport function createDateTimeFormat(skeleton, pattern) {\n    // we ignore certain patterns that are unsupported to avoid this expensive op.\n    if (unwantedDTCs.test(pattern))\n        return undefined;\n\n    var formatObj = {\n        originalPattern: pattern\n    };\n\n    // Replace the pattern string with the one required by the specification, whilst\n    // at the same time evaluating it for the subsets and formats\n    formatObj.extendedPattern = pattern.replace(expDTComponents, function ($0) {\n        // See which symbol we're dealing with\n        switch ($0.charAt(0)) {\n\n            // --- Era\n            case 'G':\n                return '{era}';\n\n            // --- Year\n            case 'y':\n            case 'Y':\n            case 'u':\n            case 'U':\n            case 'r':\n                return '{year}';\n\n            // --- Quarter (not supported in this polyfill)\n            case 'Q':\n            case 'q':\n                return '{quarter}';\n\n            // --- Month\n            case 'M':\n            case 'L':\n                return '{month}';\n\n            // --- Week (not supported in this polyfill)\n            case 'w':\n            case 'W':\n                return '{weekday}';\n\n            // --- Day\n            case 'd':\n            case 'D':\n            case 'F':\n            case 'g':\n                return '{day}';\n\n            // --- Week Day\n            case 'E':\n            case 'e':\n            case 'c':\n                return '{weekday}';\n\n            // --- Period\n            case 'a':\n            case 'b':\n            case 'B':\n                return '{ampm}';\n\n            // --- Hour\n            case 'h':\n            case 'H':\n            case 'k':\n            case 'K':\n                return '{hour}';\n\n            // --- Minute\n            case 'm':\n                return '{minute}';\n\n            // --- Second\n            case 's':\n            case 'S':\n            case 'A':\n                return '{second}';\n\n            // --- Timezone\n            case 'z':\n            case 'Z':\n            case 'O':\n            case 'v':\n            case 'V':\n            case 'X':\n            case 'x':\n                return '{timeZoneName}';\n\n        }\n    });\n\n    // Match the skeleton string with the one required by the specification\n    // this implementation is based on the Date Field Symbol Table:\n    // http://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n    // Note: we are adding extra data to the formatObject even though this polyfill\n    //       might not support it.\n    skeleton.replace(expDTComponents, function ($0) {\n        // See which symbol we're dealing with\n        switch ($0.charAt(0)) {\n\n            // --- Era\n            case 'G':\n                formatObj.era = [ 'short', 'short', 'short', 'long', 'narrow' ][$0.length-1];\n                break;\n\n            // --- Year\n            case 'y':\n            case 'Y':\n            case 'u':\n            case 'U':\n                formatObj.year = $0.length === 2 ? '2-digit' : 'numeric';\n                break;\n            // case 'r':\n                // r: 1..n - For the Gregorian calendar, the 'r' year is the same as the 'u' year.\n                // break;\n\n            // --- Quarter (not supported in this polyfill)\n            case 'Q':\n            case 'q':\n                formatObj.quarter = [ 'numeric', '2-digit', 'short', 'long', 'narrow' ][$0.length-1];\n                break;\n\n            // --- Month\n            case 'M':\n            case 'L':\n                formatObj.month = [ 'numeric', '2-digit', 'short', 'long', 'narrow' ][$0.length-1];\n                break;\n\n            // --- Week (not supported in this polyfill)\n            case 'w':\n                // week of the year\n                formatObj.week = $0.length === 2 ? '2-digit' : 'numeric';\n                break;\n            case 'W':\n                // week of the month\n                formatObj.week = 'numeric';\n                break;\n\n            // --- Day\n            case 'd':\n                // day of the month\n                formatObj.day = $0.length === 2 ? '2-digit' : 'numeric';\n                break;\n            case 'D':\n                // day of the year\n                formatObj.day = 'numeric';\n                break;\n            case 'F':\n                // day of the week\n                formatObj.day = 'numeric';\n                break;\n            // case 'g':\n                // 1..n: Modified Julian day\n                // break;\n\n            // --- Week Day\n            case 'E':\n                // day of the week\n                formatObj.weekday = [ 'short', 'short', 'short', 'long', 'narrow', 'short' ][$0.length-1];\n                break;\n            case 'e':\n                // local day of the week\n                formatObj.weekday = [ 'numeric', '2-digit', 'short', 'long', 'narrow', 'short' ][$0.length-1];\n                break;\n            case 'c':\n                // stand alone local day of the week\n                formatObj.weekday = [ 'numeric', undefined, 'short', 'long', 'narrow', 'short' ][$0.length-1];\n                break;\n\n            // --- Period\n            case 'a': // AM, PM\n            case 'b': // am, pm, noon, midnight\n            case 'B': // flexible day periods\n                formatObj.hour12 = true;\n                break;\n\n            // --- Hour\n            case 'H':\n            case 'k':\n                formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n                break;\n            case 'h':\n            case 'K':\n                formatObj.hour12 = true; // 12-hour-cycle time formats (using h or K)\n                formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n                break;\n\n            // --- Minute\n            case 'm':\n                formatObj.minute = $0.length === 2 ? '2-digit' : 'numeric';\n                break;\n\n            // --- Second\n            case 's':\n                formatObj.second = $0.length === 2 ? '2-digit' : 'numeric';\n                break;\n            // case 'S': // 1..n: factional seconds\n            // case 'A': // 1..n: miliseconds in day\n\n            // --- Timezone\n            case 'z': // 1..3, 4: specific non-location format\n            case 'Z': // 1..3, 4, 5: The ISO8601 varios formats\n            case 'O': // 1, 4: miliseconds in day short, long\n            case 'v': // 1, 4: generic non-location format\n            case 'V': // 1, 2, 3, 4: time zone ID or city\n            case 'X': // 1, 2, 3, 4: The ISO8601 varios formats\n            case 'x': // 1, 2, 3, 4: The ISO8601 varios formats\n                // this polyfill only supports much, for now, we are just doing something dummy\n                formatObj.timeZoneName = $0.length < 4 ? 'short' : 'long';\n                break;\n\n        }\n    });\n\n    return computeFinalPatterns(formatObj);\n}\n\n/**\n * Processes DateTime formats from CLDR to an easier-to-parse format.\n * the result of this operation should be cached the first time a particular\n * calendar is analyzed.\n *\n * The specification requires we support at least the following subsets of\n * date/time components:\n *\n *   - 'weekday', 'year', 'month', 'day', 'hour', 'minute', 'second'\n *   - 'weekday', 'year', 'month', 'day'\n *   - 'year', 'month', 'day'\n *   - 'year', 'month'\n *   - 'month', 'day'\n *   - 'hour', 'minute', 'second'\n *   - 'hour', 'minute'\n *\n * We need to cherry pick at least these subsets from the CLDR data and convert\n * them into the pattern objects used in the ECMA-402 API.\n */\nexport function createDateTimeFormats(formats) {\n    var availableFormats = formats.availableFormats;\n    var timeFormats = formats.timeFormats;\n    var dateFormats = formats.dateFormats;\n    var result = [];\n    var skeleton, pattern, computed, i, j;\n    var timeRelatedFormats = [];\n    var dateRelatedFormats = [];\n\n    // Map available (custom) formats into a pattern for createDateTimeFormats\n    for (skeleton in availableFormats) {\n        if (availableFormats.hasOwnProperty(skeleton)) {\n            pattern = availableFormats[skeleton];\n            computed = createDateTimeFormat(skeleton, pattern);\n            if (computed) {\n                result.push(computed);\n                // in some cases, the format is only displaying date specific props\n                // or time specific props, in which case we need to also produce the\n                // combined formats.\n                if (isDateFormatOnly(computed)) {\n                    dateRelatedFormats.push(computed);\n                } else if (isTimeFormatOnly(computed)) {\n                    timeRelatedFormats.push(computed);\n                }\n            }\n        }\n    }\n\n    // Map time formats into a pattern for createDateTimeFormats\n    for (skeleton in timeFormats) {\n        if (timeFormats.hasOwnProperty(skeleton)) {\n            pattern = timeFormats[skeleton];\n            computed = createDateTimeFormat(skeleton, pattern);\n            if (computed) {\n                result.push(computed);\n                timeRelatedFormats.push(computed);\n            }\n        }\n    }\n\n    // Map date formats into a pattern for createDateTimeFormats\n    for (skeleton in dateFormats) {\n        if (dateFormats.hasOwnProperty(skeleton)) {\n            pattern = dateFormats[skeleton];\n            computed = createDateTimeFormat(skeleton, pattern);\n            if (computed) {\n                result.push(computed);\n                dateRelatedFormats.push(computed);\n            }\n        }\n    }\n\n    // combine custom time and custom date formats when they are orthogonals to complete the\n    // formats supported by CLDR.\n    // This Algo is based on section \"Missing Skeleton Fields\" from:\n    // http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n    for (i = 0; i < timeRelatedFormats.length; i += 1) {\n        for (j = 0; j < dateRelatedFormats.length; j += 1) {\n            if (dateRelatedFormats[j].month === 'long') {\n                pattern = dateRelatedFormats[j].weekday ? formats.full : formats.long;\n            } else if (dateRelatedFormats[j].month === 'short') {\n                pattern = formats.medium;\n            } else {\n                pattern = formats.short;\n            }\n            computed = joinDateAndTimeFormats(dateRelatedFormats[j], timeRelatedFormats[i]);\n            computed.originalPattern = pattern;\n            computed.extendedPattern = pattern\n                .replace('{0}', timeRelatedFormats[i].extendedPattern)\n                .replace('{1}', dateRelatedFormats[j].extendedPattern)\n                .replace(/^[,\\s]+|[,\\s]+$/gi, '');\n            result.push(computeFinalPatterns(computed));\n        }\n    }\n\n    return result;\n}\n","/**\n * @license Copyright 2013 Andy Earnshaw, MIT License\n *\n * Implements the ECMAScript Internationalization API in ES5-compatible environments,\n * following the ECMA-402 specification as closely as possible\n *\n * ECMA-402: http://ecma-international.org/ecma-402/1.0/\n *\n * CLDR format locale data should be provided using IntlPolyfill.__addLocaleData().\n */\n/*jshint esnext: true, proto:true, eqnull:true, boss:true, laxbreak:true, newcap:false, shadow:true, funcscope:true */\n\nimport {\n    expBCP47Syntax,\n    expExtSequences,\n    expVariantDupes,\n    expSingletonDupes\n} from './exp';\n\nimport {\n    createDateTimeFormats\n} from \"./cldr\";\n\nvar Intl = {},\n\n    realDefineProp = (function () {\n        var sentinel = {};\n        try {\n            Object.defineProperty(sentinel, 'a', {});\n            return 'a' in sentinel;\n        } catch (e) {\n            return false;\n        }\n    })(),\n\n    // Need a workaround for getters in ES3\n    es3  = !realDefineProp && !Object.prototype.__defineGetter__,\n\n    // We use this a lot (and need it for proto-less objects)\n    hop = Object.prototype.hasOwnProperty,\n\n    // Naive defineProperty for compatibility\n    defineProperty = realDefineProp ? Object.defineProperty : function (obj, name, desc) {\n        if ('get' in desc && obj.__defineGetter__)\n            obj.__defineGetter__(name, desc.get);\n\n        else if (!hop.call(obj, name) || 'value' in desc)\n            obj[name] = desc.value;\n    },\n\n    // Array.prototype.indexOf, as good as we need it to be\n    arrIndexOf = Array.prototype.indexOf || function (search) {\n        /*jshint validthis:true */\n        var t = this;\n        if (!t.length)\n            return -1;\n\n        for (var i = arguments[1] || 0, max = t.length; i < max; i++) {\n            if (t[i] === search)\n                return i;\n        }\n\n        return -1;\n    },\n\n    // Create an object with the specified prototype (2nd arg required for Record)\n    objCreate = Object.create || function (proto, props) {\n        var obj;\n\n        function F() {}\n        F.prototype = proto;\n        obj = new F();\n\n        for (var k in props) {\n            if (hop.call(props, k))\n                defineProperty(obj, k, props[k]);\n        }\n\n        return obj;\n    },\n\n    // Snapshot some (hopefully still) native built-ins\n    arrSlice  = Array.prototype.slice,\n    arrConcat = Array.prototype.concat,\n    arrPush   = Array.prototype.push,\n    arrJoin   = Array.prototype.join,\n    arrShift  = Array.prototype.shift,\n    arrUnshift= Array.prototype.unshift,\n\n    // Naive Function.prototype.bind for compatibility\n    fnBind = Function.prototype.bind || function (thisObj) {\n        var fn = this,\n            args = arrSlice.call(arguments, 1);\n\n        // All our (presently) bound functions have either 1 or 0 arguments. By returning\n        // different function signatures, we can pass some tests in ES3 environments\n        if (fn.length === 1) {\n            return function (a) {\n                return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n            };\n        }\n        else {\n            return function () {\n                return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n            };\n        }\n    },\n\n    // Default locale is the first-added locale data for us\n    defaultLocale,\n\n    // Object housing internal properties for constructors\n    internals = objCreate(null),\n\n    // Keep internal properties internal\n    secret = Math.random(),\n\n    // An object map of date component keys, saves using a regex later\n    dateWidths = objCreate(null, { narrow:{}, short:{}, long:{} }),\n\n    // Each constructor prototype should be an instance of the constructor itself, but we\n    // can't initialise them as such until some locale data has been added, so this is how\n    // we keep track\n    numberFormatProtoInitialised = false,\n    dateTimeFormatProtoInitialised = false,\n\n    // Some regular expressions we're using\n    expCurrencyCode = /^[A-Z]{3}$/,\n    expUnicodeExSeq = /-u(?:-[0-9a-z]{2,8})+/gi, // See `extension` below\n\n    // IANA Subtag Registry redundant tag and subtag maps\n    redundantTags = {\n        tags: {\n            \"art-lojban\":   \"jbo\",       \"i-ami\":        \"ami\",       \"i-bnn\":       \"bnn\",  \"i-hak\":      \"hak\",\n            \"i-klingon\":    \"tlh\",       \"i-lux\":        \"lb\",        \"i-navajo\":    \"nv\",   \"i-pwn\":      \"pwn\",\n            \"i-tao\":        \"tao\",       \"i-tay\":        \"tay\",       \"i-tsu\":       \"tsu\",  \"no-bok\":     \"nb\",\n            \"no-nyn\":       \"nn\",        \"sgn-BE-FR\":    \"sfb\",       \"sgn-BE-NL\":   \"vgt\",  \"sgn-CH-DE\":  \"sgg\",\n            \"zh-guoyu\":     \"cmn\",       \"zh-hakka\":     \"hak\",       \"zh-min-nan\":  \"nan\",  \"zh-xiang\":   \"hsn\",\n            \"sgn-BR\":       \"bzs\",       \"sgn-CO\":       \"csn\",       \"sgn-DE\":      \"gsg\",  \"sgn-DK\":     \"dsl\",\n            \"sgn-ES\":       \"ssp\",       \"sgn-FR\":       \"fsl\",       \"sgn-GB\":      \"bfi\",  \"sgn-GR\":     \"gss\",\n            \"sgn-IE\":       \"isg\",       \"sgn-IT\":       \"ise\",       \"sgn-JP\":      \"jsl\",  \"sgn-MX\":     \"mfs\",\n            \"sgn-NI\":       \"ncs\",       \"sgn-NL\":       \"dse\",       \"sgn-NO\":      \"nsl\",  \"sgn-PT\":     \"psr\",\n            \"sgn-SE\":       \"swl\",       \"sgn-US\":       \"ase\",       \"sgn-ZA\":      \"sfs\",  \"zh-cmn\":     \"cmn\",\n            \"zh-cmn-Hans\":  \"cmn-Hans\",  \"zh-cmn-Hant\":  \"cmn-Hant\",  \"zh-gan\":      \"gan\",  \"zh-wuu\":     \"wuu\",\n            \"zh-yue\":       \"yue\"\n        },\n        subtags: {\n              BU: \"MM\",   DD: \"DE\",   FX: \"FR\",   TP: \"TL\",   YD: \"YE\",   ZR: \"CD\",  heploc: \"alalc97\",\n            'in': \"id\",   iw: \"he\",   ji:  \"yi\",  jw: \"jv\",   mo: \"ro\",  ayx: \"nun\", bjd: \"drl\",\n             ccq: \"rki\", cjr: \"mom\", cka: \"cmr\", cmk: \"xch\", drh: \"khk\", drw: \"prs\", gav: \"dev\",\n             hrr: \"jal\", ibi: \"opa\", kgh: \"kml\", lcq: \"ppr\", mst: \"mry\", myt: \"mry\", sca: \"hle\",\n             tie: \"ras\", tkk: \"twm\", tlw: \"weo\", tnf: \"prs\", ybd: \"rki\", yma: \"lrr\"\n        },\n        extLang: {\n            aao: [ \"aao\", \"ar\"  ], abh: [ \"abh\", \"ar\"  ], abv: [ \"abv\", \"ar\"  ], acm: [ \"acm\", \"ar\"  ],\n            acq: [ \"acq\", \"ar\"  ], acw: [ \"acw\", \"ar\"  ], acx: [ \"acx\", \"ar\"  ], acy: [ \"acy\", \"ar\"  ],\n            adf: [ \"adf\", \"ar\"  ], ads: [ \"ads\", \"sgn\" ], aeb: [ \"aeb\", \"ar\"  ], aec: [ \"aec\", \"ar\"  ],\n            aed: [ \"aed\", \"sgn\" ], aen: [ \"aen\", \"sgn\" ], afb: [ \"afb\", \"ar\"  ], afg: [ \"afg\", \"sgn\" ],\n            ajp: [ \"ajp\", \"ar\"  ], apc: [ \"apc\", \"ar\"  ], apd: [ \"apd\", \"ar\"  ], arb: [ \"arb\", \"ar\"  ],\n            arq: [ \"arq\", \"ar\"  ], ars: [ \"ars\", \"ar\"  ], ary: [ \"ary\", \"ar\"  ], arz: [ \"arz\", \"ar\"  ],\n            ase: [ \"ase\", \"sgn\" ], asf: [ \"asf\", \"sgn\" ], asp: [ \"asp\", \"sgn\" ], asq: [ \"asq\", \"sgn\" ],\n            asw: [ \"asw\", \"sgn\" ], auz: [ \"auz\", \"ar\"  ], avl: [ \"avl\", \"ar\"  ], ayh: [ \"ayh\", \"ar\"  ],\n            ayl: [ \"ayl\", \"ar\"  ], ayn: [ \"ayn\", \"ar\"  ], ayp: [ \"ayp\", \"ar\"  ], bbz: [ \"bbz\", \"ar\"  ],\n            bfi: [ \"bfi\", \"sgn\" ], bfk: [ \"bfk\", \"sgn\" ], bjn: [ \"bjn\", \"ms\"  ], bog: [ \"bog\", \"sgn\" ],\n            bqn: [ \"bqn\", \"sgn\" ], bqy: [ \"bqy\", \"sgn\" ], btj: [ \"btj\", \"ms\"  ], bve: [ \"bve\", \"ms\"  ],\n            bvl: [ \"bvl\", \"sgn\" ], bvu: [ \"bvu\", \"ms\"  ], bzs: [ \"bzs\", \"sgn\" ], cdo: [ \"cdo\", \"zh\"  ],\n            cds: [ \"cds\", \"sgn\" ], cjy: [ \"cjy\", \"zh\"  ], cmn: [ \"cmn\", \"zh\"  ], coa: [ \"coa\", \"ms\"  ],\n            cpx: [ \"cpx\", \"zh\"  ], csc: [ \"csc\", \"sgn\" ], csd: [ \"csd\", \"sgn\" ], cse: [ \"cse\", \"sgn\" ],\n            csf: [ \"csf\", \"sgn\" ], csg: [ \"csg\", \"sgn\" ], csl: [ \"csl\", \"sgn\" ], csn: [ \"csn\", \"sgn\" ],\n            csq: [ \"csq\", \"sgn\" ], csr: [ \"csr\", \"sgn\" ], czh: [ \"czh\", \"zh\"  ], czo: [ \"czo\", \"zh\"  ],\n            doq: [ \"doq\", \"sgn\" ], dse: [ \"dse\", \"sgn\" ], dsl: [ \"dsl\", \"sgn\" ], dup: [ \"dup\", \"ms\"  ],\n            ecs: [ \"ecs\", \"sgn\" ], esl: [ \"esl\", \"sgn\" ], esn: [ \"esn\", \"sgn\" ], eso: [ \"eso\", \"sgn\" ],\n            eth: [ \"eth\", \"sgn\" ], fcs: [ \"fcs\", \"sgn\" ], fse: [ \"fse\", \"sgn\" ], fsl: [ \"fsl\", \"sgn\" ],\n            fss: [ \"fss\", \"sgn\" ], gan: [ \"gan\", \"zh\"  ], gds: [ \"gds\", \"sgn\" ], gom: [ \"gom\", \"kok\" ],\n            gse: [ \"gse\", \"sgn\" ], gsg: [ \"gsg\", \"sgn\" ], gsm: [ \"gsm\", \"sgn\" ], gss: [ \"gss\", \"sgn\" ],\n            gus: [ \"gus\", \"sgn\" ], hab: [ \"hab\", \"sgn\" ], haf: [ \"haf\", \"sgn\" ], hak: [ \"hak\", \"zh\"  ],\n            hds: [ \"hds\", \"sgn\" ], hji: [ \"hji\", \"ms\"  ], hks: [ \"hks\", \"sgn\" ], hos: [ \"hos\", \"sgn\" ],\n            hps: [ \"hps\", \"sgn\" ], hsh: [ \"hsh\", \"sgn\" ], hsl: [ \"hsl\", \"sgn\" ], hsn: [ \"hsn\", \"zh\"  ],\n            icl: [ \"icl\", \"sgn\" ], ils: [ \"ils\", \"sgn\" ], inl: [ \"inl\", \"sgn\" ], ins: [ \"ins\", \"sgn\" ],\n            ise: [ \"ise\", \"sgn\" ], isg: [ \"isg\", \"sgn\" ], isr: [ \"isr\", \"sgn\" ], jak: [ \"jak\", \"ms\"  ],\n            jax: [ \"jax\", \"ms\"  ], jcs: [ \"jcs\", \"sgn\" ], jhs: [ \"jhs\", \"sgn\" ], jls: [ \"jls\", \"sgn\" ],\n            jos: [ \"jos\", \"sgn\" ], jsl: [ \"jsl\", \"sgn\" ], jus: [ \"jus\", \"sgn\" ], kgi: [ \"kgi\", \"sgn\" ],\n            knn: [ \"knn\", \"kok\" ], kvb: [ \"kvb\", \"ms\"  ], kvk: [ \"kvk\", \"sgn\" ], kvr: [ \"kvr\", \"ms\"  ],\n            kxd: [ \"kxd\", \"ms\"  ], lbs: [ \"lbs\", \"sgn\" ], lce: [ \"lce\", \"ms\"  ], lcf: [ \"lcf\", \"ms\"  ],\n            liw: [ \"liw\", \"ms\"  ], lls: [ \"lls\", \"sgn\" ], lsg: [ \"lsg\", \"sgn\" ], lsl: [ \"lsl\", \"sgn\" ],\n            lso: [ \"lso\", \"sgn\" ], lsp: [ \"lsp\", \"sgn\" ], lst: [ \"lst\", \"sgn\" ], lsy: [ \"lsy\", \"sgn\" ],\n            ltg: [ \"ltg\", \"lv\"  ], lvs: [ \"lvs\", \"lv\"  ], lzh: [ \"lzh\", \"zh\"  ], max: [ \"max\", \"ms\"  ],\n            mdl: [ \"mdl\", \"sgn\" ], meo: [ \"meo\", \"ms\"  ], mfa: [ \"mfa\", \"ms\"  ], mfb: [ \"mfb\", \"ms\"  ],\n            mfs: [ \"mfs\", \"sgn\" ], min: [ \"min\", \"ms\"  ], mnp: [ \"mnp\", \"zh\"  ], mqg: [ \"mqg\", \"ms\"  ],\n            mre: [ \"mre\", \"sgn\" ], msd: [ \"msd\", \"sgn\" ], msi: [ \"msi\", \"ms\"  ], msr: [ \"msr\", \"sgn\" ],\n            mui: [ \"mui\", \"ms\"  ], mzc: [ \"mzc\", \"sgn\" ], mzg: [ \"mzg\", \"sgn\" ], mzy: [ \"mzy\", \"sgn\" ],\n            nan: [ \"nan\", \"zh\"  ], nbs: [ \"nbs\", \"sgn\" ], ncs: [ \"ncs\", \"sgn\" ], nsi: [ \"nsi\", \"sgn\" ],\n            nsl: [ \"nsl\", \"sgn\" ], nsp: [ \"nsp\", \"sgn\" ], nsr: [ \"nsr\", \"sgn\" ], nzs: [ \"nzs\", \"sgn\" ],\n            okl: [ \"okl\", \"sgn\" ], orn: [ \"orn\", \"ms\"  ], ors: [ \"ors\", \"ms\"  ], pel: [ \"pel\", \"ms\"  ],\n            pga: [ \"pga\", \"ar\"  ], pks: [ \"pks\", \"sgn\" ], prl: [ \"prl\", \"sgn\" ], prz: [ \"prz\", \"sgn\" ],\n            psc: [ \"psc\", \"sgn\" ], psd: [ \"psd\", \"sgn\" ], pse: [ \"pse\", \"ms\"  ], psg: [ \"psg\", \"sgn\" ],\n            psl: [ \"psl\", \"sgn\" ], pso: [ \"pso\", \"sgn\" ], psp: [ \"psp\", \"sgn\" ], psr: [ \"psr\", \"sgn\" ],\n            pys: [ \"pys\", \"sgn\" ], rms: [ \"rms\", \"sgn\" ], rsi: [ \"rsi\", \"sgn\" ], rsl: [ \"rsl\", \"sgn\" ],\n            sdl: [ \"sdl\", \"sgn\" ], sfb: [ \"sfb\", \"sgn\" ], sfs: [ \"sfs\", \"sgn\" ], sgg: [ \"sgg\", \"sgn\" ],\n            sgx: [ \"sgx\", \"sgn\" ], shu: [ \"shu\", \"ar\"  ], slf: [ \"slf\", \"sgn\" ], sls: [ \"sls\", \"sgn\" ],\n            sqk: [ \"sqk\", \"sgn\" ], sqs: [ \"sqs\", \"sgn\" ], ssh: [ \"ssh\", \"ar\"  ], ssp: [ \"ssp\", \"sgn\" ],\n            ssr: [ \"ssr\", \"sgn\" ], svk: [ \"svk\", \"sgn\" ], swc: [ \"swc\", \"sw\"  ], swh: [ \"swh\", \"sw\"  ],\n            swl: [ \"swl\", \"sgn\" ], syy: [ \"syy\", \"sgn\" ], tmw: [ \"tmw\", \"ms\"  ], tse: [ \"tse\", \"sgn\" ],\n            tsm: [ \"tsm\", \"sgn\" ], tsq: [ \"tsq\", \"sgn\" ], tss: [ \"tss\", \"sgn\" ], tsy: [ \"tsy\", \"sgn\" ],\n            tza: [ \"tza\", \"sgn\" ], ugn: [ \"ugn\", \"sgn\" ], ugy: [ \"ugy\", \"sgn\" ], ukl: [ \"ukl\", \"sgn\" ],\n            uks: [ \"uks\", \"sgn\" ], urk: [ \"urk\", \"ms\"  ], uzn: [ \"uzn\", \"uz\"  ], uzs: [ \"uzs\", \"uz\"  ],\n            vgt: [ \"vgt\", \"sgn\" ], vkk: [ \"vkk\", \"ms\"  ], vkt: [ \"vkt\", \"ms\"  ], vsi: [ \"vsi\", \"sgn\" ],\n            vsl: [ \"vsl\", \"sgn\" ], vsv: [ \"vsv\", \"sgn\" ], wuu: [ \"wuu\", \"zh\"  ], xki: [ \"xki\", \"sgn\" ],\n            xml: [ \"xml\", \"sgn\" ], xmm: [ \"xmm\", \"ms\"  ], xms: [ \"xms\", \"sgn\" ], yds: [ \"yds\", \"sgn\" ],\n            ysl: [ \"ysl\", \"sgn\" ], yue: [ \"yue\", \"zh\"  ], zib: [ \"zib\", \"sgn\" ], zlm: [ \"zlm\", \"ms\"  ],\n            zmi: [ \"zmi\", \"ms\"  ], zsl: [ \"zsl\", \"sgn\" ], zsm: [ \"zsm\", \"ms\"  ]\n        }\n    },\n\n    // Currency minor units output from get-4217 grunt task, formatted\n    currencyMinorUnits = {\n        BHD: 3, BYR: 0, XOF: 0, BIF: 0, XAF: 0, CLF: 4, CLP: 0, KMF: 0, DJF: 0,\n        XPF: 0, GNF: 0, ISK: 0, IQD: 3, JPY: 0, JOD: 3, KRW: 0, KWD: 3, LYD: 3,\n        OMR: 3, PYG: 0, RWF: 0, TND: 3, UGX: 0, UYI: 0, VUV: 0, VND: 0\n    };\n\n// Sect 6.2 Language Tags\n// ======================\n\n/**\n * The IsStructurallyValidLanguageTag abstract operation verifies that the locale\n * argument (which must be a String value)\n *\n * - represents a well-formed BCP 47 language tag as specified in RFC 5646 section\n *   2.1, or successor,\n * - does not include duplicate variant subtags, and\n * - does not include duplicate singleton subtags.\n *\n * The abstract operation returns true if locale can be generated from the ABNF\n * grammar in section 2.1 of the RFC, starting with Language-Tag, and does not\n * contain duplicate variant or singleton subtags (other than as a private use\n * subtag). It returns false otherwise. Terminal value characters in the grammar are\n * interpreted as the Unicode equivalents of the ASCII octet values given.\n */\nfunction /* 6.2.2 */IsStructurallyValidLanguageTag(locale) {\n    // represents a well-formed BCP 47 language tag as specified in RFC 5646\n    if (!expBCP47Syntax.test(locale))\n        return false;\n\n    // does not include duplicate variant subtags, and\n    if (expVariantDupes.test(locale))\n        return false;\n\n    // does not include duplicate singleton subtags.\n    if (expSingletonDupes.test(locale))\n        return false;\n\n    return true;\n}\n\n/**\n * The CanonicalizeLanguageTag abstract operation returns the canonical and case-\n * regularized form of the locale argument (which must be a String value that is\n * a structurally valid BCP 47 language tag as verified by the\n * IsStructurallyValidLanguageTag abstract operation). It takes the steps\n * specified in RFC 5646 section 4.5, or successor, to bring the language tag\n * into canonical form, and to regularize the case of the subtags, but does not\n * take the steps to bring a language tag into extlang form and to reorder\n * variant subtags.\n\n * The specifications for extensions to BCP 47 language tags, such as RFC 6067,\n * may include canonicalization rules for the extension subtag sequences they\n * define that go beyond the canonicalization rules of RFC 5646 section 4.5.\n * Implementations are allowed, but not required, to apply these additional rules.\n */\nfunction /* 6.2.3 */CanonicalizeLanguageTag (locale) {\n    var match, parts;\n\n    // A language tag is in 'canonical form' when the tag is well-formed\n    // according to the rules in Sections 2.1 and 2.2\n\n    // Section 2.1 says all subtags use lowercase...\n    locale = locale.toLowerCase();\n\n    // ...with 2 exceptions: 'two-letter and four-letter subtags that neither\n    // appear at the start of the tag nor occur after singletons.  Such two-letter\n    // subtags are all uppercase (as in the tags \"en-CA-x-ca\" or \"sgn-BE-FR\") and\n    // four-letter subtags are titlecase (as in the tag \"az-Latn-x-latn\").\n    parts = locale.split('-');\n    for (var i = 1, max = parts.length; i < max; i++) {\n        // Two-letter subtags are all uppercase\n        if (parts[i].length === 2)\n            parts[i] = parts[i].toUpperCase();\n\n        // Four-letter subtags are titlecase\n        else if (parts[i].length === 4)\n            parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].slice(1);\n\n        // Is it a singleton?\n        else if (parts[i].length === 1 && parts[i] !== 'x')\n            break;\n    }\n    locale = arrJoin.call(parts, '-');\n\n    // The steps laid out in RFC 5646 section 4.5 are as follows:\n\n    // 1.  Extension sequences are ordered into case-insensitive ASCII order\n    //     by singleton subtag.\n    if ((match = locale.match(expExtSequences)) && match.length > 1) {\n        // The built-in sort() sorts by ASCII order, so use that\n        match.sort();\n\n        // Replace all extensions with the joined, sorted array\n        locale = locale.replace(\n            RegExp('(?:' + expExtSequences.source + ')+', 'i'),\n            arrJoin.call(match, '')\n        );\n    }\n\n    // 2.  Redundant or grandfathered tags are replaced by their 'Preferred-\n    //     Value', if there is one.\n    if (hop.call(redundantTags.tags, locale))\n        locale = redundantTags.tags[locale];\n\n    // 3.  Subtags are replaced by their 'Preferred-Value', if there is one.\n    //     For extlangs, the original primary language subtag is also\n    //     replaced if there is a primary language subtag in the 'Preferred-\n    //     Value'.\n    parts = locale.split('-');\n\n    for (var i = 1, max = parts.length; i < max; i++) {\n        if (hop.call(redundantTags.subtags, parts[i]))\n            parts[i] = redundantTags.subtags[parts[i]];\n\n        else if (hop.call(redundantTags.extLang, parts[i])) {\n            parts[i] = redundantTags.extLang[parts[i]][0];\n\n            // For extlang tags, the prefix needs to be removed if it is redundant\n            if (i === 1 && redundantTags.extLang[parts[1]][1] === parts[0]) {\n                parts = arrSlice.call(parts, i++);\n                max -= 1;\n            }\n        }\n    }\n\n    return arrJoin.call(parts, '-');\n}\n\n/**\n * The DefaultLocale abstract operation returns a String value representing the\n * structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the\n * host environments current locale.\n */\nfunction /* 6.2.4 */DefaultLocale () {\n    return defaultLocale;\n}\n\n// Sect 6.3 Currency Codes\n// =======================\n\n/**\n * The IsWellFormedCurrencyCode abstract operation verifies that the currency argument\n * (after conversion to a String value) represents a well-formed 3-letter ISO currency\n * code. The following steps are taken:\n */\nfunction /* 6.3.1 */IsWellFormedCurrencyCode(currency) {\n    var\n        // 1. Let `c` be ToString(currency)\n        c = String(currency),\n\n        // 2. Let `normalized` be the result of mapping c to upper case as described\n        //    in 6.1.\n        normalized = toLatinUpperCase(c);\n\n    // 3. If the string length of normalized is not 3, return false.\n    // 4. If normalized contains any character that is not in the range \"A\" to \"Z\"\n    //    (U+0041 to U+005A), return false.\n    if (expCurrencyCode.test(normalized) === false)\n        return false;\n\n    // 5. Return true\n    return true;\n}\n\n// Sect 9.2 Abstract Operations\n// ============================\nfunction /* 9.2.1 */CanonicalizeLocaleList (locales) {\n// The abstract operation CanonicalizeLocaleList takes the following steps:\n\n    // 1. If locales is undefined, then a. Return a new empty List\n    if (locales === undefined)\n        return new List();\n\n    var\n        // 2. Let seen be a new empty List.\n        seen = new List(),\n\n        // 3. If locales is a String value, then\n        //    a. Let locales be a new array created as if by the expression new\n        //    Array(locales) where Array is the standard built-in constructor with\n        //    that name and locales is the value of locales.\n        locales = typeof locales === 'string' ? [ locales ] : locales,\n\n        // 4. Let O be ToObject(locales).\n        O = toObject(locales),\n\n        // 5. Let lenValue be the result of calling the [[Get]] internal method of\n        //    O with the argument \"length\".\n        // 6. Let len be ToUint32(lenValue).\n        len = O.length,\n\n        // 7. Let k be 0.\n        k = 0;\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n        var\n            // a. Let Pk be ToString(k).\n            Pk = String(k),\n\n            // b. Let kPresent be the result of calling the [[HasProperty]] internal\n            //    method of O with argument Pk.\n            kPresent = Pk in O;\n\n        // c. If kPresent is true, then\n        if (kPresent) {\n            var\n                // i. Let kValue be the result of calling the [[Get]] internal\n                //     method of O with argument Pk.\n                kValue = O[Pk];\n\n            // ii. If the type of kValue is not String or Object, then throw a\n            //     TypeError exception.\n            if (kValue == null || (typeof kValue !== 'string' && typeof kValue !== 'object'))\n                throw new TypeError('String or Object type expected');\n\n            var\n                // iii. Let tag be ToString(kValue).\n                tag = String(kValue);\n\n            // iv. If the result of calling the abstract operation\n            //     IsStructurallyValidLanguageTag (defined in 6.2.2), passing tag as\n            //     the argument, is false, then throw a RangeError exception.\n            if (!IsStructurallyValidLanguageTag(tag))\n                throw new RangeError(\"'\" + tag + \"' is not a structurally valid language tag\");\n\n            // v. Let tag be the result of calling the abstract operation\n            //    CanonicalizeLanguageTag (defined in 6.2.3), passing tag as the\n            //    argument.\n            tag = CanonicalizeLanguageTag(tag);\n\n            // vi. If tag is not an element of seen, then append tag as the last\n            //     element of seen.\n            if (arrIndexOf.call(seen, tag) === -1)\n                arrPush.call(seen, tag);\n        }\n\n        // d. Increase k by 1.\n        k++;\n    }\n\n    // 9. Return seen.\n    return seen;\n}\n\n/**\n * The BestAvailableLocale abstract operation compares the provided argument\n * locale, which must be a String value with a structurally valid and\n * canonicalized BCP 47 language tag, against the locales in availableLocales and\n * returns either the longest non-empty prefix of locale that is an element of\n * availableLocales, or undefined if there is no such element. It uses the\n * fallback mechanism of RFC 4647, section 3.4. The following steps are taken:\n */\nfunction /* 9.2.2 */BestAvailableLocale (availableLocales, locale) {\n    var\n       // 1. Let candidate be locale\n       candidate = locale;\n\n    // 2. Repeat\n    while (true) {\n        // a. If availableLocales contains an element equal to candidate, then return\n        // candidate.\n        if (arrIndexOf.call(availableLocales, candidate) > -1)\n            return candidate;\n\n        var\n            // b. Let pos be the character index of the last occurrence of \"-\"\n            // (U+002D) within candidate. If that character does not occur, return\n            // undefined.\n            pos = candidate.lastIndexOf('-');\n\n        if (pos < 0)\n            return;\n\n        // c. If pos  2 and the character \"-\" occurs at index pos-2 of candidate,\n        //    then decrease pos by 2.\n        if (pos >= 2 && candidate.charAt(pos - 2) === '-')\n            pos -= 2;\n\n        // d. Let candidate be the substring of candidate from position 0, inclusive,\n        //    to position pos, exclusive.\n        candidate = candidate.substring(0, pos);\n    }\n}\n\n/**\n * The LookupMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The following steps are taken:\n */\nfunction /* 9.2.3 */LookupMatcher (availableLocales, requestedLocales) {\n    var\n        // 1. Let i be 0.\n        i = 0,\n\n        // 2. Let len be the number of elements in requestedLocales.\n        len = requestedLocales.length,\n\n        // 3. Let availableLocale be undefined.\n        availableLocale;\n\n    // 4. Repeat while i < len and availableLocale is undefined:\n    while (i < len && !availableLocale) {\n        var\n            // a. Let locale be the element of requestedLocales at 0-origined list\n            //    position i.\n            locale = requestedLocales[i],\n\n            // b. Let noExtensionsLocale be the String value that is locale with all\n            //    Unicode locale extension sequences removed.\n            noExtensionsLocale = String(locale).replace(expUnicodeExSeq, ''),\n\n            // c. Let availableLocale be the result of calling the\n            //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n            //    arguments availableLocales and noExtensionsLocale.\n            availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\n        // d. Increase i by 1.\n        i++;\n    }\n\n    var\n        // 5. Let result be a new Record.\n        result = new Record();\n\n    // 6. If availableLocale is not undefined, then\n    if (availableLocale !== undefined) {\n        // a. Set result.[[locale]] to availableLocale.\n        result['[[locale]]'] = availableLocale;\n\n        // b. If locale and noExtensionsLocale are not the same String value, then\n        if (String(locale) !== String(noExtensionsLocale)) {\n            var\n                // i. Let extension be the String value consisting of the first\n                //    substring of locale that is a Unicode locale extension sequence.\n                extension = locale.match(expUnicodeExSeq)[0],\n\n                // ii. Let extensionIndex be the character position of the initial\n                //     \"-\" of the first Unicode locale extension sequence within locale.\n                extensionIndex = locale.indexOf('-u-');\n\n            // iii. Set result.[[extension]] to extension.\n            result['[[extension]]'] = extension;\n\n            // iv. Set result.[[extensionIndex]] to extensionIndex.\n            result['[[extensionIndex]]'] = extensionIndex;\n        }\n    }\n    // 7. Else\n    else\n        // a. Set result.[[locale]] to the value returned by the DefaultLocale abstract\n        //    operation (defined in 6.2.4).\n        result['[[locale]]'] = DefaultLocale();\n\n    // 8. Return result\n    return result;\n}\n\n/**\n * The BestFitMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The algorithm is implementation dependent, but should produce results\n * that a typical user of the requested locales would perceive as at least as\n * good as those produced by the LookupMatcher abstract operation. Options\n * specified through Unicode locale extension sequences must be ignored by the\n * algorithm. Information about such subsequences is returned separately.\n * The abstract operation returns a record with a [[locale]] field, whose value\n * is the language tag of the selected locale, which must be an element of\n * availableLocales. If the language tag of the request locale that led to the\n * selected locale contained a Unicode locale extension sequence, then the\n * returned record also contains an [[extension]] field whose value is the first\n * Unicode locale extension sequence, and an [[extensionIndex]] field whose value\n * is the index of the first Unicode locale extension sequence within the request\n * locale language tag.\n */\nfunction /* 9.2.4 */BestFitMatcher (availableLocales, requestedLocales) {\n    return LookupMatcher(availableLocales, requestedLocales);\n}\n\n/**\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\n * requestedLocales against the locales in availableLocales and determines the\n * best available language to meet the request. availableLocales and\n * requestedLocales must be provided as List values, options as a Record.\n */\nfunction /* 9.2.5 */ResolveLocale (availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {\n    if (availableLocales.length === 0) {\n        throw new ReferenceError('No locale data has been provided for this object yet.');\n    }\n\n    // The following steps are taken:\n    var\n        // 1. Let matcher be the value of options.[[localeMatcher]].\n        matcher = options['[[localeMatcher]]'];\n\n    // 2. If matcher is \"lookup\", then\n    if (matcher === 'lookup')\n        var\n            // a. Let r be the result of calling the LookupMatcher abstract operation\n            //    (defined in 9.2.3) with arguments availableLocales and\n            //    requestedLocales.\n            r = LookupMatcher(availableLocales, requestedLocales);\n\n    // 3. Else\n    else\n        var\n            // a. Let r be the result of calling the BestFitMatcher abstract\n            //    operation (defined in 9.2.4) with arguments availableLocales and\n            //    requestedLocales.\n            r = BestFitMatcher(availableLocales, requestedLocales);\n\n    var\n        // 4. Let foundLocale be the value of r.[[locale]].\n        foundLocale = r['[[locale]]'];\n\n    // 5. If r has an [[extension]] field, then\n    if (hop.call(r, '[[extension]]'))\n        var\n            // a. Let extension be the value of r.[[extension]].\n            extension = r['[[extension]]'],\n            // b. Let extensionIndex be the value of r.[[extensionIndex]].\n            extensionIndex = r['[[extensionIndex]]'],\n            // c. Let split be the standard built-in function object defined in ES5,\n            //    15.5.4.14.\n            split = String.prototype.split,\n            // d. Let extensionSubtags be the result of calling the [[Call]] internal\n            //    method of split with extension as the this value and an argument\n            //    list containing the single item \"-\".\n            extensionSubtags = split.call(extension, '-'),\n            // e. Let extensionSubtagsLength be the result of calling the [[Get]]\n            //    internal method of extensionSubtags with argument \"length\".\n            extensionSubtagsLength = extensionSubtags.length;\n\n    var\n        // 6. Let result be a new Record.\n        result = new Record();\n\n    // 7. Set result.[[dataLocale]] to foundLocale.\n    result['[[dataLocale]]'] = foundLocale;\n\n    var\n        // 8. Let supportedExtension be \"-u\".\n        supportedExtension = '-u',\n        // 9. Let i be 0.\n        i = 0,\n        // 10. Let len be the result of calling the [[Get]] internal method of\n        //     relevantExtensionKeys with argument \"length\".\n        len = relevantExtensionKeys.length;\n\n    // 11 Repeat while i < len:\n    while (i < len) {\n        var\n            // a. Let key be the result of calling the [[Get]] internal method of\n            //    relevantExtensionKeys with argument ToString(i).\n            key = relevantExtensionKeys[i],\n            // b. Let foundLocaleData be the result of calling the [[Get]] internal\n            //    method of localeData with the argument foundLocale.\n            foundLocaleData = localeData[foundLocale],\n            // c. Let keyLocaleData be the result of calling the [[Get]] internal\n            //    method of foundLocaleData with the argument key.\n            keyLocaleData = foundLocaleData[key],\n            // d. Let value be the result of calling the [[Get]] internal method of\n            //    keyLocaleData with argument \"0\".\n            value = keyLocaleData['0'],\n            // e. Let supportedExtensionAddition be \"\".\n            supportedExtensionAddition = '',\n            // f. Let indexOf be the standard built-in function object defined in\n            //    ES5, 15.4.4.14.\n            indexOf = arrIndexOf;\n\n        // g. If extensionSubtags is not undefined, then\n        if (extensionSubtags !== undefined) {\n            var\n                // i. Let keyPos be the result of calling the [[Call]] internal\n                //    method of indexOf with extensionSubtags as the this value and\n                // an argument list containing the single item key.\n                keyPos = indexOf.call(extensionSubtags, key);\n\n            // ii. If keyPos  -1, then\n            if (keyPos !== -1) {\n                // 1. If keyPos + 1 < extensionSubtagsLength and the length of the\n                //    result of calling the [[Get]] internal method of\n                //    extensionSubtags with argument ToString(keyPos +1) is greater\n                //    than 2, then\n                if (keyPos + 1 < extensionSubtagsLength\n                        && extensionSubtags[keyPos + 1].length > 2) {\n                    var\n                        // a. Let requestedValue be the result of calling the [[Get]]\n                        //    internal method of extensionSubtags with argument\n                        //    ToString(keyPos + 1).\n                        requestedValue = extensionSubtags[keyPos + 1],\n                        // b. Let valuePos be the result of calling the [[Call]]\n                        //    internal method of indexOf with keyLocaleData as the\n                        //    this value and an argument list containing the single\n                        //    item requestedValue.\n                        valuePos = indexOf.call(keyLocaleData, requestedValue);\n\n                    // c. If valuePos  -1, then\n                    if (valuePos !== -1)\n                        var\n                            // i. Let value be requestedValue.\n                            value = requestedValue,\n                            // ii. Let supportedExtensionAddition be the\n                            //     concatenation of \"-\", key, \"-\", and value.\n                            supportedExtensionAddition = '-' + key + '-' + value;\n                }\n                // 2. Else\n                else {\n                    var\n                        // a. Let valuePos be the result of calling the [[Call]]\n                        // internal method of indexOf with keyLocaleData as the this\n                        // value and an argument list containing the single item\n                        // \"true\".\n                        valuePos = indexOf(keyLocaleData, 'true');\n\n                    // b. If valuePos  -1, then\n                    if (valuePos !== -1)\n                        var\n                            // i. Let value be \"true\".\n                            value = 'true';\n                }\n            }\n        }\n        // h. If options has a field [[<key>]], then\n        if (hop.call(options, '[[' + key + ']]')) {\n            var\n                // i. Let optionsValue be the value of options.[[<key>]].\n                optionsValue = options['[[' + key + ']]'];\n\n            // ii. If the result of calling the [[Call]] internal method of indexOf\n            //     with keyLocaleData as the this value and an argument list\n            //     containing the single item optionsValue is not -1, then\n            if (indexOf.call(keyLocaleData, optionsValue) !== -1) {\n                // 1. If optionsValue is not equal to value, then\n                if (optionsValue !== value) {\n                    // a. Let value be optionsValue.\n                    value = optionsValue;\n                    // b. Let supportedExtensionAddition be \"\".\n                    supportedExtensionAddition = '';\n                }\n            }\n        }\n        // i. Set result.[[<key>]] to value.\n        result['[[' + key + ']]'] = value;\n\n        // j. Append supportedExtensionAddition to supportedExtension.\n        supportedExtension += supportedExtensionAddition;\n\n        // k. Increase i by 1.\n        i++;\n    }\n    // 12. If the length of supportedExtension is greater than 2, then\n    if (supportedExtension.length > 2) {\n        var\n            // a. Let preExtension be the substring of foundLocale from position 0,\n            //    inclusive, to position extensionIndex, exclusive.\n            preExtension = foundLocale.substring(0, extensionIndex),\n            // b. Let postExtension be the substring of foundLocale from position\n            //    extensionIndex to the end of the string.\n            postExtension = foundLocale.substring(extensionIndex),\n            // c. Let foundLocale be the concatenation of preExtension,\n            //    supportedExtension, and postExtension.\n            foundLocale = preExtension + supportedExtension + postExtension;\n    }\n    // 13. Set result.[[locale]] to foundLocale.\n    result['[[locale]]'] = foundLocale;\n\n    // 14. Return result.\n    return result;\n}\n\n/**\n * The LookupSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n * The following steps are taken:\n */\nfunction /* 9.2.6 */LookupSupportedLocales (availableLocales, requestedLocales) {\n    var\n        // 1. Let len be the number of elements in requestedLocales.\n        len = requestedLocales.length,\n        // 2. Let subset be a new empty List.\n        subset = new List(),\n        // 3. Let k be 0.\n        k = 0;\n\n    // 4. Repeat while k < len\n    while (k < len) {\n        var\n            // a. Let locale be the element of requestedLocales at 0-origined list\n            //    position k.\n            locale = requestedLocales[k],\n            // b. Let noExtensionsLocale be the String value that is locale with all\n            //    Unicode locale extension sequences removed.\n            noExtensionsLocale = String(locale).replace(expUnicodeExSeq, ''),\n            // c. Let availableLocale be the result of calling the\n            //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n            //    arguments availableLocales and noExtensionsLocale.\n            availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\n        // d. If availableLocale is not undefined, then append locale to the end of\n        //    subset.\n        if (availableLocale !== undefined)\n            arrPush.call(subset, locale);\n\n        // e. Increment k by 1.\n        k++;\n    }\n\n    var\n        // 5. Let subsetArray be a new Array object whose elements are the same\n        //    values in the same order as the elements of subset.\n        subsetArray = arrSlice.call(subset);\n\n    // 6. Return subsetArray.\n    return subsetArray;\n}\n\n/**\n * The BestFitSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the Best Fit Matcher\n * algorithm. Locales appear in the same order in the returned list as in\n * requestedLocales. The steps taken are implementation dependent.\n */\nfunction /*9.2.7 */BestFitSupportedLocales (availableLocales, requestedLocales) {\n    // ###TODO: implement this function as described by the specification###\n    return LookupSupportedLocales(availableLocales, requestedLocales);\n}\n\n/**\n * The SupportedLocales abstract operation returns the subset of the provided BCP\n * 47 language priority list requestedLocales for which availableLocales has a\n * matching locale. Two algorithms are available to match the locales: the Lookup\n * algorithm described in RFC 4647 section 3.4, and an implementation dependent\n * best-fit algorithm. Locales appear in the same order in the returned list as\n * in requestedLocales. The following steps are taken:\n */\nfunction /*9.2.8 */SupportedLocales (availableLocales, requestedLocales, options) {\n    // 1. If options is not undefined, then\n    if (options !== undefined) {\n        var\n            // a. Let options be ToObject(options).\n            options = new Record(toObject(options)),\n            // b. Let matcher be the result of calling the [[Get]] internal method of\n            //    options with argument \"localeMatcher\".\n            matcher = options.localeMatcher;\n\n        // c. If matcher is not undefined, then\n        if (matcher !== undefined) {\n            // i. Let matcher be ToString(matcher).\n            matcher = String(matcher);\n\n            // ii. If matcher is not \"lookup\" or \"best fit\", then throw a RangeError\n            //     exception.\n            if (matcher !== 'lookup' && matcher !== 'best fit')\n                throw new RangeError('matcher should be \"lookup\" or \"best fit\"');\n        }\n    }\n    // 2. If matcher is undefined or \"best fit\", then\n    if (matcher === undefined || matcher === 'best fit')\n        var\n            // a. Let subset be the result of calling the BestFitSupportedLocales\n            //    abstract operation (defined in 9.2.7) with arguments\n            //    availableLocales and requestedLocales.\n            subset = BestFitSupportedLocales(availableLocales, requestedLocales);\n    // 3. Else\n    else\n        var\n            // a. Let subset be the result of calling the LookupSupportedLocales\n            //    abstract operation (defined in 9.2.6) with arguments\n            //    availableLocales and requestedLocales.\n            subset = LookupSupportedLocales(availableLocales, requestedLocales);\n\n    // 4. For each named own property name P of subset,\n    for (var P in subset) {\n        if (!hop.call(subset, P))\n            continue;\n\n        // a. Let desc be the result of calling the [[GetOwnProperty]] internal\n        //    method of subset with P.\n        // b. Set desc.[[Writable]] to false.\n        // c. Set desc.[[Configurable]] to false.\n        // d. Call the [[DefineOwnProperty]] internal method of subset with P, desc,\n        //    and true as arguments.\n        defineProperty(subset, P, {\n            writable: false, configurable: false, value: subset[P]\n        });\n    }\n    // \"Freeze\" the array so no new elements can be added\n    defineProperty(subset, 'length', { writable: false });\n\n    // 5. Return subset\n    return subset;\n}\n\n/**\n * The GetOption abstract operation extracts the value of the property named\n * property from the provided options object, converts it to the required type,\n * checks whether it is one of a List of allowed values, and fills in a fallback\n * value if necessary.\n */\nfunction /*9.2.9 */GetOption (options, property, type, values, fallback) {\n    var\n        // 1. Let value be the result of calling the [[Get]] internal method of\n        //    options with argument property.\n        value = options[property];\n\n    // 2. If value is not undefined, then\n    if (value !== undefined) {\n        // a. Assert: type is \"boolean\" or \"string\".\n        // b. If type is \"boolean\", then let value be ToBoolean(value).\n        // c. If type is \"string\", then let value be ToString(value).\n        value = type === 'boolean' ? Boolean(value)\n                  : (type === 'string' ? String(value) : value);\n\n        // d. If values is not undefined, then\n        if (values !== undefined) {\n            // i. If values does not contain an element equal to value, then throw a\n            //    RangeError exception.\n            if (arrIndexOf.call(values, value) === -1)\n                throw new RangeError(\"'\" + value + \"' is not an allowed value for `\" + property +'`');\n        }\n\n        // e. Return value.\n        return value;\n    }\n    // Else return fallback.\n    return fallback;\n}\n\n/**\n * The GetNumberOption abstract operation extracts a property value from the\n * provided options object, converts it to a Number value, checks whether it is\n * in the allowed range, and fills in a fallback value if necessary.\n */\nfunction /* 9.2.10 */GetNumberOption (options, property, minimum, maximum, fallback) {\n    var\n        // 1. Let value be the result of calling the [[Get]] internal method of\n        //    options with argument property.\n        value = options[property];\n\n    // 2. If value is not undefined, then\n    if (value !== undefined) {\n        // a. Let value be ToNumber(value).\n        value = Number(value);\n\n        // b. If value is NaN or less than minimum or greater than maximum, throw a\n        //    RangeError exception.\n        if (isNaN(value) || value < minimum || value > maximum)\n            throw new RangeError('Value is not a number or outside accepted range');\n\n        // c. Return floor(value).\n        return Math.floor(value);\n    }\n    // 3. Else return fallback.\n    return fallback;\n}\n\n// 11.1 The Intl.NumberFormat constructor\n// ======================================\n\n// Define the NumberFormat constructor internally so it cannot be tainted\nfunction NumberFormatConstructor () {\n    var locales = arguments[0];\n    var options = arguments[1];\n\n    if (!this || this === Intl) {\n        return new Intl.NumberFormat(locales, options);\n    }\n\n    return InitializeNumberFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'NumberFormat', {\n    configurable: true,\n    writable: true,\n    value: NumberFormatConstructor\n});\n\n// Must explicitly set prototypes as unwritable\ndefineProperty(Intl.NumberFormat, 'prototype', {\n    writable: false\n});\n\n/**\n * The abstract operation InitializeNumberFormat accepts the arguments\n * numberFormat (which must be an object), locales, and options. It initializes\n * numberFormat as a NumberFormat object.\n */\nfunction /*11.1.1.1 */InitializeNumberFormat (numberFormat, locales, options) {\n    var\n    // This will be a internal properties object if we're not already initialized\n        internal = getInternalProperties(numberFormat),\n\n    // Create an object whose props can be used to restore the values of RegExp props\n        regexpState = createRegExpRestore();\n\n    // 1. If numberFormat has an [[initializedIntlObject]] internal property with\n    // value true, throw a TypeError exception.\n    if (internal['[[initializedIntlObject]]'] === true)\n        throw new TypeError('`this` object has already been initialized as an Intl object');\n\n    // Need this to access the `internal` object\n    defineProperty(numberFormat, '__getInternalProperties', {\n        value: function () {\n            // NOTE: Non-standard, for internal use only\n            if (arguments[0] === secret)\n                return internal;\n        }\n    });\n\n    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n    internal['[[initializedIntlObject]]'] = true;\n\n    var\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n        requestedLocales = CanonicalizeLocaleList(locales);\n\n    // 4. If options is undefined, then\n    if (options === undefined)\n        // a. Let options be the result of creating a new object as if by the\n        // expression new Object() where Object is the standard built-in constructor\n        // with that name.\n        options = {};\n\n    // 5. Else\n    else\n        // a. Let options be ToObject(options).\n        options = toObject(options);\n\n    var\n    // 6. Let opt be a new Record.\n        opt = new Record(),\n\n    // 7. Let matcher be the result of calling the GetOption abstract operation\n    //    (defined in 9.2.9) with the arguments options, \"localeMatcher\", \"string\",\n    //    a List containing the two String values \"lookup\" and \"best fit\", and\n    //    \"best fit\".\n        matcher =  GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\n    // 8. Set opt.[[localeMatcher]] to matcher.\n    opt['[[localeMatcher]]'] = matcher;\n\n    var\n    // 9. Let NumberFormat be the standard built-in object that is the initial value\n    //    of Intl.NumberFormat.\n    // 10. Let localeData be the value of the [[localeData]] internal property of\n    //     NumberFormat.\n        localeData = internals.NumberFormat['[[localeData]]'],\n\n    // 11. Let r be the result of calling the ResolveLocale abstract operation\n    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n    //     NumberFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n    //     internal property of NumberFormat, and localeData.\n        r = ResolveLocale(\n                internals.NumberFormat['[[availableLocales]]'], requestedLocales,\n                opt, internals.NumberFormat['[[relevantExtensionKeys]]'], localeData\n            );\n\n    // 12. Set the [[locale]] internal property of numberFormat to the value of\n    //     r.[[locale]].\n    internal['[[locale]]'] = r['[[locale]]'];\n\n    // 13. Set the [[numberingSystem]] internal property of numberFormat to the value\n    //     of r.[[nu]].\n    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\n    // The specification doesn't tell us to do this, but it's helpful later on\n    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\n    var\n    // 14. Let dataLocale be the value of r.[[dataLocale]].\n        dataLocale = r['[[dataLocale]]'],\n\n    // 15. Let s be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"style\", \"string\", a List containing the three String\n    //     values \"decimal\", \"percent\", and \"currency\", and \"decimal\".\n        s = GetOption(options, 'style', 'string', new List('decimal', 'percent', 'currency'), 'decimal');\n\n    // 16. Set the [[style]] internal property of numberFormat to s.\n    internal['[[style]]'] = s;\n\n    var\n    // 17. Let c be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"currency\", \"string\", undefined, and undefined.\n        c = GetOption(options, 'currency', 'string');\n\n    // 18. If c is not undefined and the result of calling the\n    //     IsWellFormedCurrencyCode abstract operation (defined in 6.3.1) with\n    //     argument c is false, then throw a RangeError exception.\n    if (c !== undefined && !IsWellFormedCurrencyCode(c))\n        throw new RangeError(\"'\" + c + \"' is not a valid currency code\");\n\n    // 19. If s is \"currency\" and c is undefined, throw a TypeError exception.\n    if (s === 'currency' && c === undefined)\n        throw new TypeError('Currency code is required when style is currency');\n\n    // 20. If s is \"currency\", then\n    if (s === 'currency') {\n        // a. Let c be the result of converting c to upper case as specified in 6.1.\n        c = c.toUpperCase();\n\n        // b. Set the [[currency]] internal property of numberFormat to c.\n        internal['[[currency]]'] = c;\n\n        var\n        // c. Let cDigits be the result of calling the CurrencyDigits abstract\n        //    operation (defined below) with argument c.\n            cDigits = CurrencyDigits(c);\n    }\n\n    var\n    // 21. Let cd be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"currencyDisplay\", \"string\", a List containing the\n    //     three String values \"code\", \"symbol\", and \"name\", and \"symbol\".\n        cd = GetOption(options, 'currencyDisplay', 'string', new List('code', 'symbol', 'name'), 'symbol');\n\n    // 22. If s is \"currency\", then set the [[currencyDisplay]] internal property of\n    //     numberFormat to cd.\n    if (s === 'currency')\n        internal['[[currencyDisplay]]'] = cd;\n\n    var\n    // 23. Let mnid be the result of calling the GetNumberOption abstract operation\n    //     (defined in 9.2.10) with arguments options, \"minimumIntegerDigits\", 1, 21,\n    //     and 1.\n        mnid = GetNumberOption(options, 'minimumIntegerDigits', 1, 21, 1);\n\n    // 24. Set the [[minimumIntegerDigits]] internal property of numberFormat to mnid.\n    internal['[[minimumIntegerDigits]]'] = mnid;\n\n    var\n    // 25. If s is \"currency\", then let mnfdDefault be cDigits; else let mnfdDefault\n    //     be 0.\n        mnfdDefault = s === 'currency' ? cDigits : 0,\n\n    // 26. Let mnfd be the result of calling the GetNumberOption abstract operation\n    //     with arguments options, \"minimumFractionDigits\", 0, 20, and mnfdDefault.\n        mnfd = GetNumberOption(options, 'minimumFractionDigits', 0, 20, mnfdDefault);\n\n    // 27. Set the [[minimumFractionDigits]] internal property of numberFormat to mnfd.\n    internal['[[minimumFractionDigits]]'] = mnfd;\n\n    var\n    // 28. If s is \"currency\", then let mxfdDefault be max(mnfd, cDigits); else if s\n    //     is \"percent\", then let mxfdDefault be max(mnfd, 0); else let mxfdDefault\n    //     be max(mnfd, 3).\n        mxfdDefault = s === 'currency' ? Math.max(mnfd, cDigits)\n                    : (s === 'percent' ? Math.max(mnfd, 0) : Math.max(mnfd, 3)),\n\n    // 29. Let mxfd be the result of calling the GetNumberOption abstract operation\n    //     with arguments options, \"maximumFractionDigits\", mnfd, 20, and mxfdDefault.\n        mxfd = GetNumberOption(options, 'maximumFractionDigits', mnfd, 20, mxfdDefault);\n\n    // 30. Set the [[maximumFractionDigits]] internal property of numberFormat to mxfd.\n    internal['[[maximumFractionDigits]]'] = mxfd;\n\n    var\n    // 31. Let mnsd be the result of calling the [[Get]] internal method of options\n    //     with argument \"minimumSignificantDigits\".\n        mnsd = options.minimumSignificantDigits,\n\n    // 32. Let mxsd be the result of calling the [[Get]] internal method of options\n    //     with argument \"maximumSignificantDigits\".\n        mxsd = options.maximumSignificantDigits;\n\n    // 33. If mnsd is not undefined or mxsd is not undefined, then:\n    if (mnsd !== undefined || mxsd !== undefined) {\n        // a. Let mnsd be the result of calling the GetNumberOption abstract\n        //    operation with arguments options, \"minimumSignificantDigits\", 1, 21,\n        //    and 1.\n        mnsd = GetNumberOption(options, 'minimumSignificantDigits', 1, 21, 1);\n\n        // b. Let mxsd be the result of calling the GetNumberOption abstract\n        //     operation with arguments options, \"maximumSignificantDigits\", mnsd,\n        //     21, and 21.\n        mxsd = GetNumberOption(options, 'maximumSignificantDigits', mnsd, 21, 21);\n\n        // c. Set the [[minimumSignificantDigits]] internal property of numberFormat\n        //    to mnsd, and the [[maximumSignificantDigits]] internal property of\n        //    numberFormat to mxsd.\n        internal['[[minimumSignificantDigits]]'] = mnsd;\n        internal['[[maximumSignificantDigits]]'] = mxsd;\n    }\n    var\n    // 34. Let g be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"useGrouping\", \"boolean\", undefined, and true.\n        g = GetOption(options, 'useGrouping', 'boolean', undefined, true);\n\n    // 35. Set the [[useGrouping]] internal property of numberFormat to g.\n    internal['[[useGrouping]]'] = g;\n\n    var\n    // 36. Let dataLocaleData be the result of calling the [[Get]] internal method of\n    //     localeData with argument dataLocale.\n        dataLocaleData = localeData[dataLocale],\n\n    // 37. Let patterns be the result of calling the [[Get]] internal method of\n    //     dataLocaleData with argument \"patterns\".\n        patterns = dataLocaleData.patterns;\n\n    // 38. Assert: patterns is an object (see 11.2.3)\n\n    var\n    // 39. Let stylePatterns be the result of calling the [[Get]] internal method of\n    //     patterns with argument s.\n        stylePatterns = patterns[s];\n\n    // 40. Set the [[positivePattern]] internal property of numberFormat to the\n    //     result of calling the [[Get]] internal method of stylePatterns with the\n    //     argument \"positivePattern\".\n    internal['[[positivePattern]]'] = stylePatterns.positivePattern;\n\n    // 41. Set the [[negativePattern]] internal property of numberFormat to the\n    //     result of calling the [[Get]] internal method of stylePatterns with the\n    //     argument \"negativePattern\".\n    internal['[[negativePattern]]'] = stylePatterns.negativePattern;\n\n    // 42. Set the [[boundFormat]] internal property of numberFormat to undefined.\n    internal['[[boundFormat]]'] = undefined;\n\n    // 43. Set the [[initializedNumberFormat]] internal property of numberFormat to\n    //     true.\n    internal['[[initializedNumberFormat]]'] = true;\n\n    // In ES3, we need to pre-bind the format() function\n    if (es3)\n        numberFormat.format = GetFormatNumber.call(numberFormat);\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // Return the newly initialised object\n    return numberFormat;\n}\n\nfunction CurrencyDigits(currency) {\n    // When the CurrencyDigits abstract operation is called with an argument currency\n    // (which must be an upper case String value), the following steps are taken:\n\n    // 1. If the ISO 4217 currency and funds code list contains currency as an\n    // alphabetic code, then return the minor unit value corresponding to the\n    // currency from the list; else return 2.\n    return currencyMinorUnits[currency] !== undefined\n                ? currencyMinorUnits[currency]\n                : 2;\n}\n\n/* 11.2.3 */internals.NumberFormat = {\n    '[[availableLocales]]': [],\n    '[[relevantExtensionKeys]]': ['nu'],\n    '[[localeData]]': {}\n};\n\n/**\n * When the supportedLocalesOf method of Intl.NumberFormat is called, the\n * following steps are taken:\n */\n/* 11.2.2 */defineProperty(Intl.NumberFormat, 'supportedLocalesOf', {\n    configurable: true,\n    writable: true,\n    value: fnBind.call(supportedLocalesOf, internals.NumberFormat)\n});\n\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * NumberFormat object.\n */\n/* 11.3.2 */defineProperty(Intl.NumberFormat.prototype, 'format', {\n    configurable: true,\n    get: GetFormatNumber\n});\n\nfunction GetFormatNumber() {\n        var internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\n        // Satisfy test 11.3_b\n        if (!internal || !internal['[[initializedNumberFormat]]'])\n            throw new TypeError('`this` value for format() is not an initialized Intl.NumberFormat object.');\n\n        // The value of the [[Get]] attribute is a function that takes the following\n        // steps:\n\n        // 1. If the [[boundFormat]] internal property of this NumberFormat object\n        //    is undefined, then:\n        if (internal['[[boundFormat]]'] === undefined) {\n            var\n            // a. Let F be a Function object, with internal properties set as\n            //    specified for built-in functions in ES5, 15, or successor, and the\n            //    length property set to 1, that takes the argument value and\n            //    performs the following steps:\n                F = function (value) {\n                    // i. If value is not provided, then let value be undefined.\n                    // ii. Let x be ToNumber(value).\n                    // iii. Return the result of calling the FormatNumber abstract\n                    //      operation (defined below) with arguments this and x.\n                    return FormatNumber(this, /* x = */Number(value));\n                },\n\n            // b. Let bind be the standard built-in function object defined in ES5,\n            //    15.3.4.5.\n            // c. Let bf be the result of calling the [[Call]] internal method of\n            //    bind with F as the this value and an argument list containing\n            //    the single item this.\n                bf = fnBind.call(F, this);\n\n            // d. Set the [[boundFormat]] internal property of this NumberFormat\n            //    object to bf.\n            internal['[[boundFormat]]'] = bf;\n        }\n        // Return the value of the [[boundFormat]] internal property of this\n        // NumberFormat object.\n        return internal['[[boundFormat]]'];\n    }\n\n/**\n * When the FormatNumber abstract operation is called with arguments numberFormat\n * (which must be an object initialized as a NumberFormat) and x (which must be a\n * Number value), it returns a String value representing x according to the\n * effective locale and the formatting options of numberFormat.\n */\nfunction FormatNumber (numberFormat, x) {\n    var n,\n\n    // Create an object whose props can be used to restore the values of RegExp props\n        regexpState = createRegExpRestore(),\n\n        internal = getInternalProperties(numberFormat),\n        locale = internal['[[dataLocale]]'],\n        nums   = internal['[[numberingSystem]]'],\n        data   = internals.NumberFormat['[[localeData]]'][locale],\n        ild    = data.symbols[nums] || data.symbols.latn,\n\n    // 1. Let negative be false.\n        negative = false;\n\n    // 2. If the result of isFinite(x) is false, then\n    if (isFinite(x) === false) {\n        // a. If x is NaN, then let n be an ILD String value indicating the NaN value.\n        if (isNaN(x))\n            n = ild.nan;\n\n        // b. Else\n        else {\n            // a. Let n be an ILD String value indicating infinity.\n            n = ild.infinity;\n            // b. If x < 0, then let negative be true.\n            if (x < 0)\n                negative = true;\n        }\n    }\n    // 3. Else\n    else {\n        // a. If x < 0, then\n        if (x < 0) {\n            // i. Let negative be true.\n            negative = true;\n            // ii. Let x be -x.\n            x = -x;\n        }\n\n        // b. If the value of the [[style]] internal property of numberFormat is\n        //    \"percent\", let x be 100  x.\n        if (internal['[[style]]'] === 'percent')\n            x *= 100;\n\n        // c. If the [[minimumSignificantDigits]] and [[maximumSignificantDigits]]\n        //    internal properties of numberFormat are present, then\n        if (hop.call(internal, '[[minimumSignificantDigits]]') &&\n                hop.call(internal, '[[maximumSignificantDigits]]'))\n            // i. Let n be the result of calling the ToRawPrecision abstract operation\n            //    (defined below), passing as arguments x and the values of the\n            //    [[minimumSignificantDigits]] and [[maximumSignificantDigits]]\n            //    internal properties of numberFormat.\n            n = ToRawPrecision(x,\n                  internal['[[minimumSignificantDigits]]'],\n                  internal['[[maximumSignificantDigits]]']);\n        // d. Else\n        else\n            // i. Let n be the result of calling the ToRawFixed abstract operation\n            //    (defined below), passing as arguments x and the values of the\n            //    [[minimumIntegerDigits]], [[minimumFractionDigits]], and\n            //    [[maximumFractionDigits]] internal properties of numberFormat.\n            n = ToRawFixed(x,\n                  internal['[[minimumIntegerDigits]]'],\n                  internal['[[minimumFractionDigits]]'],\n                  internal['[[maximumFractionDigits]]']);\n\n        // e. If the value of the [[numberingSystem]] internal property of\n        //    numberFormat matches one of the values in the Numbering System column\n        //    of Table 2 below, then\n        if (numSys[nums]) {\n            // i. Let digits be an array whose 10 String valued elements are the\n            //    UTF-16 string representations of the 10 digits specified in the\n            //    Digits column of Table 2 in the row containing the value of the\n            //    [[numberingSystem]] internal property.\n            var digits = numSys[internal['[[numberingSystem]]']];\n            // ii. Replace each digit in n with the value of digits[digit].\n            n = String(n).replace(/\\d/g, function (digit) {\n                return digits[digit];\n            });\n        }\n        // f. Else use an implementation dependent algorithm to map n to the\n        //    appropriate representation of n in the given numbering system.\n        else\n            n = String(n); // ###TODO###\n\n        // g. If n contains the character \".\", then replace it with an ILND String\n        //    representing the decimal separator.\n        n = n.replace(/\\./g, ild.decimal);\n\n        // h. If the value of the [[useGrouping]] internal property of numberFormat\n        //    is true, then insert an ILND String representing a grouping separator\n        //    into an ILND set of locations within the integer part of n.\n        if (internal['[[useGrouping]]'] === true) {\n            var\n                parts  = n.split(ild.decimal),\n                igr    = parts[0],\n\n                // Primary group represents the group closest to the decimal\n                pgSize = data.patterns.primaryGroupSize || 3,\n\n                // Secondary group is every other group\n                sgSize = data.patterns.secondaryGroupSize || pgSize;\n\n            // Group only if necessary\n            if (igr.length > pgSize) {\n                var\n                    groups = new List(),\n\n                    // Index of the primary grouping separator\n                    end    = igr.length - pgSize,\n\n                    // Starting index for our loop\n                    idx    = end % sgSize,\n\n                    start  = igr.slice(0, idx);\n\n                if (start.length)\n                    arrPush.call(groups, start);\n\n                // Loop to separate into secondary grouping digits\n                while (idx < end) {\n                    arrPush.call(groups, igr.slice(idx, idx + sgSize));\n                    idx += sgSize;\n                }\n\n                // Add the primary grouping digits\n                arrPush.call(groups, igr.slice(end));\n\n                parts[0] = arrJoin.call(groups, ild.group);\n            }\n\n            n = arrJoin.call(parts, ild.decimal);\n        }\n    }\n\n    var\n    // 4. If negative is true, then let result be the value of the [[negativePattern]]\n    //    internal property of numberFormat; else let result be the value of the\n    //    [[positivePattern]] internal property of numberFormat.\n        result = internal[negative === true ? '[[negativePattern]]' : '[[positivePattern]]'];\n\n    // 5. Replace the substring \"{number}\" within result with n.\n    result = result.replace('{number}', n);\n\n    // 6. If the value of the [[style]] internal property of numberFormat is\n    //    \"currency\", then:\n    if (internal['[[style]]'] === 'currency') {\n        var cd,\n        // a. Let currency be the value of the [[currency]] internal property of\n        //    numberFormat.\n            currency = internal['[[currency]]'],\n\n        // Shorthand for the currency data\n            cData = data.currencies[currency];\n\n        // b. If the value of the [[currencyDisplay]] internal property of\n        //    numberFormat is \"code\", then let cd be currency.\n        // c. Else if the value of the [[currencyDisplay]] internal property of\n        //    numberFormat is \"symbol\", then let cd be an ILD string representing\n        //    currency in short form. If the implementation does not have such a\n        //    representation of currency, then use currency itself.\n        // d. Else if the value of the [[currencyDisplay]] internal property of\n        //    numberFormat is \"name\", then let cd be an ILD string representing\n        //    currency in long form. If the implementation does not have such a\n        //    representation of currency, then use currency itself.\n        switch (internal['[[currencyDisplay]]']) {\n            case 'symbol':\n                cd = cData || currency;\n                break;\n\n            default:\n            case 'code':\n            case 'name':\n                cd = currency;\n        }\n\n        // e. Replace the substring \"{currency}\" within result with cd.\n        result = result.replace('{currency}', cd);\n    }\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // 7. Return result.\n    return result;\n}\n\n/**\n * When the ToRawPrecision abstract operation is called with arguments x (which\n * must be a finite non-negative number), minPrecision, and maxPrecision (both\n * must be integers between 1 and 21) the following steps are taken:\n */\nfunction ToRawPrecision (x, minPrecision, maxPrecision) {\n    var\n    // 1. Let p be maxPrecision.\n        p = maxPrecision;\n\n    // 2. If x = 0, then\n    if (x === 0) {\n        var\n        // a. Let m be the String consisting of p occurrences of the character \"0\".\n            m = arrJoin.call(Array (p + 1), '0'),\n        // b. Let e be 0.\n            e = 0;\n    }\n    // 3. Else\n    else {\n        // a. Let e and n be integers such that 10  n < 10 and for which the\n        //    exact mathematical value of n  10  x is as close to zero as\n        //    possible. If there are two such sets of e and n, pick the e and n for\n        //    which n  10 is larger.\n        var\n            e = log10Floor(Math.abs(x)),\n\n            // Easier to get to m from here\n            f = Math.round(Math.exp((Math.abs(e - p + 1)) * Math.LN10)),\n\n        // b. Let m be the String consisting of the digits of the decimal\n        //    representation of n (in order, with no leading zeroes)\n            m = String(Math.round(e - p + 1 < 0 ? x * f : x / f));\n    }\n\n    // 4. If e  p, then\n    if (e >= p)\n        // a. Return the concatenation of m and e-p+1 occurrences of the character \"0\".\n        return m + arrJoin.call(Array(e-p+1 + 1), '0');\n\n    // 5. If e = p-1, then\n    else if (e === p - 1)\n        // a. Return m.\n        return m;\n\n    // 6. If e  0, then\n    else if (e >= 0)\n        // a. Let m be the concatenation of the first e+1 characters of m, the character\n        //    \".\", and the remaining p(e+1) characters of m.\n        m = m.slice(0, e + 1) + '.' + m.slice(e + 1);\n\n    // 7. If e < 0, then\n    else if (e < 0)\n        // a. Let m be the concatenation of the String \"0.\", (e+1) occurrences of the\n        //    character \"0\", and the string m.\n        m = '0.' + arrJoin.call(Array (-(e+1) + 1), '0') + m;\n\n    // 8. If m contains the character \".\", and maxPrecision > minPrecision, then\n    if (m.indexOf(\".\") >= 0 && maxPrecision > minPrecision) {\n        var\n        // a. Let cut be maxPrecision  minPrecision.\n            cut = maxPrecision - minPrecision;\n\n        // b. Repeat while cut > 0 and the last character of m is \"0\":\n        while (cut > 0 && m.charAt(m.length-1) === '0') {\n            //  i. Remove the last character from m.\n            m = m.slice(0, -1);\n\n            //  ii. Decrease cut by 1.\n            cut--;\n        }\n\n        // c. If the last character of m is \".\", then\n        if (m.charAt(m.length-1) === '.')\n            //    i. Remove the last character from m.\n            m = m.slice(0, -1);\n    }\n    // 9. Return m.\n    return m;\n}\n\n/**\n * When the ToRawFixed abstract operation is called with arguments x (which must\n * be a finite non-negative number), minInteger (which must be an integer between\n * 1 and 21), minFraction, and maxFraction (which must be integers between 0 and\n * 20) the following steps are taken:\n */\nfunction ToRawFixed (x, minInteger, minFraction, maxFraction) {\n    // (or not because Number.toPrototype.toFixed does a lot of it for us)\n    var idx,\n\n        // We can pick up after the fixed formatted string (m) is created\n        m   = Number.prototype.toFixed.call(x, maxFraction),\n\n        // 4. If [maxFraction]  0, then\n        //    ...\n        //    e. Let int be the number of characters in a.\n        //\n        // 5. Else let int be the number of characters in m.\n        igr = m.split(\".\")[0].length,  // int is a reserved word\n\n        // 6. Let cut be maxFraction  minFraction.\n        cut = maxFraction - minFraction,\n\n        exp = (idx = m.indexOf('e')) > -1 ? m.slice(idx + 1) : 0;\n\n    if (exp) {\n        m = m.slice(0, idx).replace('.', '');\n        m += arrJoin.call(Array(exp - (m.length - 1) + 1), '0')\n          + '.' + arrJoin.call(Array(maxFraction + 1), '0');\n\n        igr = m.length;\n    }\n\n    // 7. Repeat while cut > 0 and the last character of m is \"0\":\n    while (cut > 0 && m.slice(-1) === \"0\") {\n        // a. Remove the last character from m.\n        m = m.slice(0, -1);\n\n        // b. Decrease cut by 1.\n        cut--;\n    }\n\n    // 8. If the last character of m is \".\", then\n    if (m.slice(-1) === \".\")\n        // a. Remove the last character from m.\n        m = m.slice(0, -1);\n\n    // 9. If int < minInteger, then\n    if (igr < minInteger)\n        // a. Let z be the String consisting of minIntegerint occurrences of the\n        //    character \"0\".\n        var z = arrJoin.call(Array(minInteger - igr + 1), '0');\n\n    // 10. Let m be the concatenation of Strings z and m.\n    // 11. Return m.\n    return (z ? z : '') + m;\n}\n\n// Sect 11.3.2 Table 2, Numbering systems\n// ======================================\nvar numSys = {\n    arab:    [ '\\u0660', '\\u0661', '\\u0662', '\\u0663', '\\u0664', '\\u0665', '\\u0666', '\\u0667', '\\u0668', '\\u0669' ],\n    arabext: [ '\\u06F0', '\\u06F1', '\\u06F2', '\\u06F3', '\\u06F4', '\\u06F5', '\\u06F6', '\\u06F7', '\\u06F8', '\\u06F9' ],\n    bali:    [ '\\u1B50', '\\u1B51', '\\u1B52', '\\u1B53', '\\u1B54', '\\u1B55', '\\u1B56', '\\u1B57', '\\u1B58', '\\u1B59' ],\n    beng:    [ '\\u09E6', '\\u09E7', '\\u09E8', '\\u09E9', '\\u09EA', '\\u09EB', '\\u09EC', '\\u09ED', '\\u09EE', '\\u09EF' ],\n    deva:    [ '\\u0966', '\\u0967', '\\u0968', '\\u0969', '\\u096A', '\\u096B', '\\u096C', '\\u096D', '\\u096E', '\\u096F' ],\n    fullwide:[ '\\uFF10', '\\uFF11', '\\uFF12', '\\uFF13', '\\uFF14', '\\uFF15', '\\uFF16', '\\uFF17', '\\uFF18', '\\uFF19' ],\n    gujr:    [ '\\u0AE6', '\\u0AE7', '\\u0AE8', '\\u0AE9', '\\u0AEA', '\\u0AEB', '\\u0AEC', '\\u0AED', '\\u0AEE', '\\u0AEF' ],\n    guru:    [ '\\u0A66', '\\u0A67', '\\u0A68', '\\u0A69', '\\u0A6A', '\\u0A6B', '\\u0A6C', '\\u0A6D', '\\u0A6E', '\\u0A6F' ],\n    hanidec: [ '\\u3007', '\\u4E00', '\\u4E8C', '\\u4E09', '\\u56DB', '\\u4E94', '\\u516D', '\\u4E03', '\\u516B', '\\u4E5D' ],\n    khmr:    [ '\\u17E0', '\\u17E1', '\\u17E2', '\\u17E3', '\\u17E4', '\\u17E5', '\\u17E6', '\\u17E7', '\\u17E8', '\\u17E9' ],\n    knda:    [ '\\u0CE6', '\\u0CE7', '\\u0CE8', '\\u0CE9', '\\u0CEA', '\\u0CEB', '\\u0CEC', '\\u0CED', '\\u0CEE', '\\u0CEF' ],\n    laoo:    [ '\\u0ED0', '\\u0ED1', '\\u0ED2', '\\u0ED3', '\\u0ED4', '\\u0ED5', '\\u0ED6', '\\u0ED7', '\\u0ED8', '\\u0ED9' ],\n    latn:    [ '\\u0030', '\\u0031', '\\u0032', '\\u0033', '\\u0034', '\\u0035', '\\u0036', '\\u0037', '\\u0038', '\\u0039' ],\n    limb:    [ '\\u1946', '\\u1947', '\\u1948', '\\u1949', '\\u194A', '\\u194B', '\\u194C', '\\u194D', '\\u194E', '\\u194F' ],\n    mlym:    [ '\\u0D66', '\\u0D67', '\\u0D68', '\\u0D69', '\\u0D6A', '\\u0D6B', '\\u0D6C', '\\u0D6D', '\\u0D6E', '\\u0D6F' ],\n    mong:    [ '\\u1810', '\\u1811', '\\u1812', '\\u1813', '\\u1814', '\\u1815', '\\u1816', '\\u1817', '\\u1818', '\\u1819' ],\n    mymr:    [ '\\u1040', '\\u1041', '\\u1042', '\\u1043', '\\u1044', '\\u1045', '\\u1046', '\\u1047', '\\u1048', '\\u1049' ],\n    orya:    [ '\\u0B66', '\\u0B67', '\\u0B68', '\\u0B69', '\\u0B6A', '\\u0B6B', '\\u0B6C', '\\u0B6D', '\\u0B6E', '\\u0B6F' ],\n    tamldec: [ '\\u0BE6', '\\u0BE7', '\\u0BE8', '\\u0BE9', '\\u0BEA', '\\u0BEB', '\\u0BEC', '\\u0BED', '\\u0BEE', '\\u0BEF' ],\n    telu:    [ '\\u0C66', '\\u0C67', '\\u0C68', '\\u0C69', '\\u0C6A', '\\u0C6B', '\\u0C6C', '\\u0C6D', '\\u0C6E', '\\u0C6F' ],\n    thai:    [ '\\u0E50', '\\u0E51', '\\u0E52', '\\u0E53', '\\u0E54', '\\u0E55', '\\u0E56', '\\u0E57', '\\u0E58', '\\u0E59' ],\n    tibt:    [ '\\u0F20', '\\u0F21', '\\u0F22', '\\u0F23', '\\u0F24', '\\u0F25', '\\u0F26', '\\u0F27', '\\u0F28', '\\u0F29' ]\n};\n\n/**\n * This function provides access to the locale and formatting options computed\n * during initialization of the object.\n *\n * The function returns a new object whose properties and attributes are set as\n * if constructed by an object literal assigning to each of the following\n * properties the value of the corresponding internal property of this\n * NumberFormat object (see 11.4): locale, numberingSystem, style, currency,\n * currencyDisplay, minimumIntegerDigits, minimumFractionDigits,\n * maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, and\n * useGrouping. Properties whose corresponding internal properties are not present\n * are not assigned.\n */\n/* 11.3.3 */defineProperty(Intl.NumberFormat.prototype, 'resolvedOptions', {\n    configurable: true,\n    writable: true,\n    value: function () {\n        var prop,\n            descs = new Record(),\n            props = [\n                'locale', 'numberingSystem', 'style', 'currency', 'currencyDisplay',\n                'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits',\n                'minimumSignificantDigits', 'maximumSignificantDigits', 'useGrouping'\n            ],\n            internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\n        // Satisfy test 11.3_b\n        if (!internal || !internal['[[initializedNumberFormat]]'])\n            throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.NumberFormat object.');\n\n        for (var i = 0, max = props.length; i < max; i++) {\n            if (hop.call(internal, prop = '[['+ props[i] +']]'))\n                descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n        }\n\n        return objCreate({}, descs);\n    }\n});\n\n// 12.1 The Intl.DateTimeFormat constructor\n// ==================================\n\n// Define the DateTimeFormat constructor internally so it cannot be tainted\nfunction DateTimeFormatConstructor () {\n    var locales = arguments[0];\n    var options = arguments[1];\n\n    if (!this || this === Intl) {\n        return new Intl.DateTimeFormat(locales, options);\n    }\n    return InitializeDateTimeFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'DateTimeFormat', {\n    configurable: true,\n    writable: true,\n    value: DateTimeFormatConstructor\n});\n\n// Must explicitly set prototypes as unwritable\ndefineProperty(DateTimeFormatConstructor, 'prototype', {\n    writable: false\n});\n\n/**\n * The abstract operation InitializeDateTimeFormat accepts the arguments dateTimeFormat\n * (which must be an object), locales, and options. It initializes dateTimeFormat as a\n * DateTimeFormat object.\n */\nfunction/* 12.1.1.1 */InitializeDateTimeFormat (dateTimeFormat, locales, options) {\n    var\n    // This will be a internal properties object if we're not already initialized\n        internal = getInternalProperties(dateTimeFormat),\n\n    // Create an object whose props can be used to restore the values of RegExp props\n        regexpState = createRegExpRestore();\n\n    // 1. If dateTimeFormat has an [[initializedIntlObject]] internal property with\n    //    value true, throw a TypeError exception.\n    if (internal['[[initializedIntlObject]]'] === true)\n        throw new TypeError('`this` object has already been initialized as an Intl object');\n\n    // Need this to access the `internal` object\n    defineProperty(dateTimeFormat, '__getInternalProperties', {\n        value: function () {\n            // NOTE: Non-standard, for internal use only\n            if (arguments[0] === secret)\n                return internal;\n        }\n    });\n\n    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n    internal['[[initializedIntlObject]]'] = true;\n\n    var\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n        requestedLocales = CanonicalizeLocaleList(locales),\n\n    // 4. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined below) with arguments options, \"any\", and \"date\".\n        options = ToDateTimeOptions(options, 'any', 'date'),\n\n    // 5. Let opt be a new Record.\n        opt = new Record();\n\n    // 6. Let matcher be the result of calling the GetOption abstract operation\n    //    (defined in 9.2.9) with arguments options, \"localeMatcher\", \"string\", a List\n    //    containing the two String values \"lookup\" and \"best fit\", and \"best fit\".\n        matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\n    // 7. Set opt.[[localeMatcher]] to matcher.\n    opt['[[localeMatcher]]'] = matcher;\n\n    var\n    // 8. Let DateTimeFormat be the standard built-in object that is the initial\n    //    value of Intl.DateTimeFormat.\n        DateTimeFormat = internals.DateTimeFormat, // This is what we *really* need\n\n    // 9. Let localeData be the value of the [[localeData]] internal property of\n    //    DateTimeFormat.\n        localeData = DateTimeFormat['[[localeData]]'],\n\n    // 10. Let r be the result of calling the ResolveLocale abstract operation\n    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n    //      DateTimeFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n    //      internal property of DateTimeFormat, and localeData.\n        r = ResolveLocale(DateTimeFormat['[[availableLocales]]'], requestedLocales,\n                opt, DateTimeFormat['[[relevantExtensionKeys]]'], localeData);\n\n    // 11. Set the [[locale]] internal property of dateTimeFormat to the value of\n    //     r.[[locale]].\n    internal['[[locale]]'] = r['[[locale]]'];\n\n    // 12. Set the [[calendar]] internal property of dateTimeFormat to the value of\n    //     r.[[ca]].\n    internal['[[calendar]]'] = r['[[ca]]'];\n\n    // 13. Set the [[numberingSystem]] internal property of dateTimeFormat to the value of\n    //     r.[[nu]].\n    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\n    // The specification doesn't tell us to do this, but it's helpful later on\n    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\n    var\n    // 14. Let dataLocale be the value of r.[[dataLocale]].\n        dataLocale = r['[[dataLocale]]'],\n\n    // 15. Let tz be the result of calling the [[Get]] internal method of options with\n    //     argument \"timeZone\".\n        tz = options.timeZone;\n\n    // 16. If tz is not undefined, then\n    if (tz !== undefined) {\n        // a. Let tz be ToString(tz).\n        // b. Convert tz to upper case as described in 6.1.\n        //    NOTE: If an implementation accepts additional time zone values, as permitted\n        //          under certain conditions by the Conformance clause, different casing\n        //          rules apply.\n        tz = toLatinUpperCase(tz);\n\n        // c. If tz is not \"UTC\", then throw a RangeError exception.\n        // ###TODO: accept more time zones###\n        if (tz !== 'UTC')\n            throw new RangeError('timeZone is not supported.');\n    }\n\n    // 17. Set the [[timeZone]] internal property of dateTimeFormat to tz.\n    internal['[[timeZone]]'] = tz;\n\n    // 18. Let opt be a new Record.\n    opt = new Record();\n\n    // 19. For each row of Table 3, except the header row, do:\n    for (var prop in dateTimeComponents) {\n        if (!hop.call(dateTimeComponents, prop))\n            continue;\n\n        var\n        // 20. Let prop be the name given in the Property column of the row.\n        // 21. Let value be the result of calling the GetOption abstract operation,\n        //     passing as argument options, the name given in the Property column of the\n        //     row, \"string\", a List containing the strings given in the Values column of\n        //     the row, and undefined.\n            value = GetOption(options, prop, 'string', dateTimeComponents[prop]);\n\n        // 22. Set opt.[[<prop>]] to value.\n        opt['[['+prop+']]'] = value;\n    }\n\n    var\n        // Assigned a value below\n        bestFormat,\n\n        // 23. Let dataLocaleData be the result of calling the [[Get]] internal method of\n        //     localeData with argument dataLocale.\n        dataLocaleData = localeData[dataLocale],\n\n        // 24. Let formats be the result of calling the [[Get]] internal method of\n        //     dataLocaleData with argument \"formats\".\n        //     Note: we process the CLDR formats into the spec'd structure\n        formats = ToDateTimeFormats(dataLocaleData.formats),\n\n        // 25. Let matcher be the result of calling the GetOption abstract operation with\n        //     arguments options, \"formatMatcher\", \"string\", a List containing the two String\n        //     values \"basic\" and \"best fit\", and \"best fit\".\n        matcher = GetOption(options, 'formatMatcher', 'string', new List('basic', 'best fit'), 'best fit');\n\n    // Optimization: caching the processed formats as a one time operation by\n    // replacing the initial structure from localeData\n    dataLocaleData.formats = formats;\n\n    // 26. If matcher is \"basic\", then\n    if (matcher === 'basic')\n        // 27. Let bestFormat be the result of calling the BasicFormatMatcher abstract\n        //     operation (defined below) with opt and formats.\n        bestFormat = BasicFormatMatcher(opt, formats);\n\n    // 28. Else\n    else\n        // 29. Let bestFormat be the result of calling the BestFitFormatMatcher\n        //     abstract operation (defined below) with opt and formats.\n        bestFormat = BestFitFormatMatcher(opt, formats);\n\n    // 30. For each row in Table 3, except the header row, do\n    for (var prop in dateTimeComponents) {\n        if (!hop.call(dateTimeComponents, prop))\n            continue;\n\n        // a. Let prop be the name given in the Property column of the row.\n        // b. Let pDesc be the result of calling the [[GetOwnProperty]] internal method of\n        //    bestFormat with argument prop.\n        // c. If pDesc is not undefined, then\n        if (hop.call(bestFormat, prop)) {\n            var\n            // i. Let p be the result of calling the [[Get]] internal method of bestFormat\n            //    with argument prop.\n                p = bestFormat[prop];\n\n            // ii. Set the [[<prop>]] internal property of dateTimeFormat to p.\n            // Diverging from spec becuase of bug #58\n            // https://github.com/tc39/ecma402/issues/58\n            internal['[['+prop+']]'] = opt['[['+prop+']]'] || p;\n        }\n    }\n\n    var\n        // Assigned a value below\n        pattern,\n\n    // 31. Let hr12 be the result of calling the GetOption abstract operation with\n    //     arguments options, \"hour12\", \"boolean\", undefined, and undefined.\n        hr12 = GetOption(options, 'hour12', 'boolean'/*, undefined, undefined*/);\n\n    // 32. If dateTimeFormat has an internal property [[hour]], then\n    if (internal['[[hour]]']) {\n        // a. If hr12 is undefined, then let hr12 be the result of calling the [[Get]]\n        //    internal method of dataLocaleData with argument \"hour12\".\n        hr12 = hr12 === undefined ? dataLocaleData.hour12 : hr12;\n\n        // b. Set the [[hour12]] internal property of dateTimeFormat to hr12.\n        internal['[[hour12]]'] = hr12;\n\n        // c. If hr12 is true, then\n        if (hr12 === true) {\n            var\n            // i. Let hourNo0 be the result of calling the [[Get]] internal method of\n            //    dataLocaleData with argument \"hourNo0\".\n                hourNo0 = dataLocaleData.hourNo0;\n\n            // ii. Set the [[hourNo0]] internal property of dateTimeFormat to hourNo0.\n            internal['[[hourNo0]]'] = hourNo0;\n\n            // iii. Let pattern be the result of calling the [[Get]] internal method of\n            //      bestFormat with argument \"pattern12\".\n            pattern = bestFormat.pattern12;\n        }\n\n        // d. Else\n        else\n            // i. Let pattern be the result of calling the [[Get]] internal method of\n            //    bestFormat with argument \"pattern\".\n            pattern = bestFormat.pattern;\n    }\n\n    // 33. Else\n    else\n        // a. Let pattern be the result of calling the [[Get]] internal method of\n        //    bestFormat with argument \"pattern\".\n        pattern = bestFormat.pattern;\n\n    // 34. Set the [[pattern]] internal property of dateTimeFormat to pattern.\n    internal['[[pattern]]'] = pattern;\n\n    // 35. Set the [[boundFormat]] internal property of dateTimeFormat to undefined.\n    internal['[[boundFormat]]'] = undefined;\n\n    // 36. Set the [[initializedDateTimeFormat]] internal property of dateTimeFormat to\n    //     true.\n    internal['[[initializedDateTimeFormat]]'] = true;\n\n    // In ES3, we need to pre-bind the format() function\n    if (es3)\n        dateTimeFormat.format = GetFormatDateTime.call(dateTimeFormat);\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // Return the newly initialised object\n    return dateTimeFormat;\n}\n\n/**\n * Several DateTimeFormat algorithms use values from the following table, which provides\n * property names and allowable values for the components of date and time formats:\n */\nvar dateTimeComponents = {\n         weekday: [ \"narrow\", \"short\", \"long\" ],\n             era: [ \"narrow\", \"short\", \"long\" ],\n            year: [ \"2-digit\", \"numeric\" ],\n           month: [ \"2-digit\", \"numeric\", \"narrow\", \"short\", \"long\" ],\n             day: [ \"2-digit\", \"numeric\" ],\n            hour: [ \"2-digit\", \"numeric\" ],\n          minute: [ \"2-digit\", \"numeric\" ],\n          second: [ \"2-digit\", \"numeric\" ],\n    timeZoneName: [ \"short\", \"long\" ]\n};\n\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\nfunction ToDateTimeFormats(formats) {\n    if (Object.prototype.toString.call(formats) === '[object Array]') {\n        return formats;\n    }\n    return createDateTimeFormats(formats);\n}\n\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\nfunction ToDateTimeOptions (options, required, defaults) {\n    // 1. If options is undefined, then let options be null, else let options be\n    //    ToObject(options).\n    if (options === undefined)\n        options = null;\n\n    else {\n        // (#12) options needs to be a Record, but it also needs to inherit properties\n        var opt2 = toObject(options);\n        options = new Record();\n\n        for (var k in opt2)\n            options[k] = opt2[k];\n    }\n\n    var\n    // 2. Let create be the standard built-in function object defined in ES5, 15.2.3.5.\n        create = objCreate,\n\n    // 3. Let options be the result of calling the [[Call]] internal method of create with\n    //    undefined as the this value and an argument list containing the single item\n    //    options.\n        options = create(options),\n\n    // 4. Let needDefaults be true.\n        needDefaults = true;\n\n    // 5. If required is \"date\" or \"any\", then\n    if (required === 'date' || required === 'any') {\n        // a. For each of the property names \"weekday\", \"year\", \"month\", \"day\":\n            // i. If the result of calling the [[Get]] internal method of options with the\n            //    property name is not undefined, then let needDefaults be false.\n        if (options.weekday !== undefined || options.year !== undefined\n                || options.month !== undefined || options.day !== undefined)\n            needDefaults = false;\n    }\n\n    // 6. If required is \"time\" or \"any\", then\n    if (required === 'time' || required === 'any') {\n        // a. For each of the property names \"hour\", \"minute\", \"second\":\n            // i. If the result of calling the [[Get]] internal method of options with the\n            //    property name is not undefined, then let needDefaults be false.\n        if (options.hour !== undefined || options.minute !== undefined || options.second !== undefined)\n                needDefaults = false;\n    }\n\n    // 7. If needDefaults is true and defaults is either \"date\" or \"all\", then\n    if (needDefaults && (defaults === 'date' || defaults === 'all'))\n        // a. For each of the property names \"year\", \"month\", \"day\":\n            // i. Call the [[DefineOwnProperty]] internal method of options with the\n            //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n            //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n        options.year = options.month = options.day = 'numeric';\n\n    // 8. If needDefaults is true and defaults is either \"time\" or \"all\", then\n    if (needDefaults && (defaults === 'time' || defaults === 'all'))\n        // a. For each of the property names \"hour\", \"minute\", \"second\":\n            // i. Call the [[DefineOwnProperty]] internal method of options with the\n            //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n            //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n        options.hour = options.minute = options.second = 'numeric';\n\n    // 9. Return options.\n    return options;\n}\n\n/**\n * When the BasicFormatMatcher abstract operation is called with two arguments options and\n * formats, the following steps are taken:\n */\nfunction BasicFormatMatcher (options, formats) {\n    return calculateScore(options, formats);\n}\n\n/**\n * Calculates score for BestFitFormatMatcher and BasicFormatMatcher.\n * Abstracted from BasicFormatMatcher section.\n */\nfunction calculateScore (options, formats, bestFit) {\n    var\n    // Additional penalty type when bestFit === true\n       diffDataTypePenalty = 8,\n\n    // 1. Let removalPenalty be 120.\n        removalPenalty = 120,\n\n    // 2. Let additionPenalty be 20.\n        additionPenalty = 20,\n\n    // 3. Let longLessPenalty be 8.\n        longLessPenalty = 8,\n\n    // 4. Let longMorePenalty be 6.\n        longMorePenalty = 6,\n\n    // 5. Let shortLessPenalty be 6.\n        shortLessPenalty = 6,\n\n    // 6. Let shortMorePenalty be 3.\n        shortMorePenalty = 3,\n\n    // 7. Let bestScore be -Infinity.\n        bestScore = -Infinity,\n\n    // 8. Let bestFormat be undefined.\n        bestFormat,\n\n    // 9. Let i be 0.\n        i = 0,\n\n    // 10. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n        len = formats.length;\n\n    // 11. Repeat while i < len:\n    while (i < len) {\n        var\n        // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n            format = formats[i],\n\n        // b. Let score be 0.\n            score = 0;\n\n        // c. For each property shown in Table 3:\n        for (var property in dateTimeComponents) {\n            if (!hop.call(dateTimeComponents, property))\n                continue;\n\n            var\n            // i. Let optionsProp be options.[[<property>]].\n                optionsProp = options['[['+ property +']]'],\n\n            // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n            //     with argument property.\n            // iii. If formatPropDesc is not undefined, then\n            //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n                formatProp = hop.call(format, property) ? format[property] : undefined;\n\n            // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n            //     additionPenalty.\n            if (optionsProp === undefined && formatProp !== undefined)\n                score -= additionPenalty;\n\n            // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n            //    removalPenalty.\n            else if (optionsProp !== undefined && formatProp === undefined)\n                score -= removalPenalty;\n\n            // vi. Else\n            else {\n                var\n                // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n                //    \"long\"].\n                    values = [ '2-digit', 'numeric', 'narrow', 'short', 'long' ],\n\n                // 2. Let optionsPropIndex be the index of optionsProp within values.\n                    optionsPropIndex = arrIndexOf.call(values, optionsProp),\n\n                // 3. Let formatPropIndex be the index of formatProp within values.\n                    formatPropIndex = arrIndexOf.call(values, formatProp),\n\n                // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n                    delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n\n                // When the bestFit argument is true, subtract additional penalty where data types are not the same\n                if (bestFit && (\n                    ((optionsProp === 'numeric' || optionsProp === '2-digit') && (formatProp !== 'numeric' && formatProp !== '2-digit'))\n                 || ((optionsProp !== 'numeric' && optionsProp !== '2-digit') && (formatProp === '2-digit' || formatProp === 'numeric'))\n                ))\n                    score -= diffDataTypePenalty;\n\n                // 5. If delta = 2, decrease score by longMorePenalty.\n                if (delta === 2)\n                    score -= longMorePenalty;\n\n                // 6. Else if delta = 1, decrease score by shortMorePenalty.\n                else if (delta === 1)\n                    score -= shortMorePenalty;\n\n                // 7. Else if delta = -1, decrease score by shortLessPenalty.\n                else if (delta === -1)\n                    score -= shortLessPenalty;\n\n                // 8. Else if delta = -2, decrease score by longLessPenalty.\n                else if (delta === -2)\n                    score -= longLessPenalty;\n            }\n        }\n\n        // d. If score > bestScore, then\n        if (score > bestScore) {\n            // i. Let bestScore be score.\n            bestScore = score;\n\n            // ii. Let bestFormat be format.\n            bestFormat = format;\n        }\n\n        // e. Increase i by 1.\n        i++;\n    }\n\n    // 12. Return bestFormat.\n    return bestFormat;\n}\n\n/**\n * When the BestFitFormatMatcher abstract operation is called with two arguments options\n * and formats, it performs implementation dependent steps, which should return a set of\n * component representations that a typical user of the selected locale would perceive as\n * at least as good as the one returned by BasicFormatMatcher.\n *\n * This polyfill defines the algorithm to be the same as BasicFormatMatcher,\n * with the addition of bonus points awarded where the requested format is of\n * the same data type as the potentially matching format.\n *\n * For example,\n *\n *     { month: 'numeric', day: 'numeric' }\n *\n * should match\n *\n *     { month: '2-digit', day: '2-digit' }\n *\n * rather than\n *\n *     { month: 'short', day: 'numeric' }\n *\n * This makes sense because a user requesting a formatted date with numeric parts would\n * not expect to see the returned format containing narrow, short or long part names\n */\nfunction BestFitFormatMatcher (options, formats) {\n    return calculateScore(options, formats, true);\n}\n\n/* 12.2.3 */internals.DateTimeFormat = {\n    '[[availableLocales]]': [],\n    '[[relevantExtensionKeys]]': ['ca', 'nu'],\n    '[[localeData]]': {}\n};\n\n/**\n * When the supportedLocalesOf method of Intl.DateTimeFormat is called, the\n * following steps are taken:\n */\n/* 12.2.2 */defineProperty(Intl.DateTimeFormat, 'supportedLocalesOf', {\n    configurable: true,\n    writable: true,\n    value: fnBind.call(supportedLocalesOf, internals.DateTimeFormat)\n});\n\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * DateTimeFormat object.\n */\n/* 12.3.2 */defineProperty(Intl.DateTimeFormat.prototype, 'format', {\n    configurable: true,\n    get: GetFormatDateTime\n});\n\nfunction GetFormatDateTime() {\n    var internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\n    // Satisfy test 12.3_b\n    if (!internal || !internal['[[initializedDateTimeFormat]]'])\n        throw new TypeError('`this` value for format() is not an initialized Intl.DateTimeFormat object.');\n\n    // The value of the [[Get]] attribute is a function that takes the following\n    // steps:\n\n    // 1. If the [[boundFormat]] internal property of this DateTimeFormat object\n    //    is undefined, then:\n    if (internal['[[boundFormat]]'] === undefined) {\n        var\n        // a. Let F be a Function object, with internal properties set as\n        //    specified for built-in functions in ES5, 15, or successor, and the\n        //    length property set to 0, that takes the argument date and\n        //    performs the following steps:\n            F = function () {\n                //   i. If date is not provided or is undefined, then let x be the\n                //      result as if by the expression Date.now() where Date.now is\n                //      the standard built-in function defined in ES5, 15.9.4.4.\n                //  ii. Else let x be ToNumber(date).\n                // iii. Return the result of calling the FormatDateTime abstract\n                //      operation (defined below) with arguments this and x.\n                var x = Number(arguments.length === 0 ? Date.now() : arguments[0]);\n                return FormatDateTime(this, x);\n            },\n        // b. Let bind be the standard built-in function object defined in ES5,\n        //    15.3.4.5.\n        // c. Let bf be the result of calling the [[Call]] internal method of\n        //    bind with F as the this value and an argument list containing\n        //    the single item this.\n            bf = fnBind.call(F, this);\n        // d. Set the [[boundFormat]] internal property of this NumberFormat\n        //    object to bf.\n        internal['[[boundFormat]]'] = bf;\n    }\n    // Return the value of the [[boundFormat]] internal property of this\n    // NumberFormat object.\n    return internal['[[boundFormat]]'];\n}\n\n/**\n * When the FormatDateTime abstract operation is called with arguments dateTimeFormat\n * (which must be an object initialized as a DateTimeFormat) and x (which must be a Number\n * value), it returns a String value representing x (interpreted as a time value as\n * specified in ES5, 15.9.1.1) according to the effective locale and the formatting\n * options of dateTimeFormat.\n */\nfunction FormatDateTime(dateTimeFormat, x) {\n    // 1. If x is not a finite Number, then throw a RangeError exception.\n    if (!isFinite(x))\n        throw new RangeError('Invalid valid date passed to format');\n\n    var\n        internal = dateTimeFormat.__getInternalProperties(secret),\n\n    // Creating restore point for properties on the RegExp object... please wait\n        regexpState = createRegExpRestore(),\n\n    // 2. Let locale be the value of the [[locale]] internal property of dateTimeFormat.\n        locale = internal['[[locale]]'],\n\n    // 3. Let nf be the result of creating a new NumberFormat object as if by the\n    // expression new Intl.NumberFormat([locale], {useGrouping: false}) where\n    // Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n        nf = new Intl.NumberFormat([locale], {useGrouping: false}),\n\n    // 4. Let nf2 be the result of creating a new NumberFormat object as if by the\n    // expression new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping:\n    // false}) where Intl.NumberFormat is the standard built-in constructor defined in\n    // 11.1.3.\n        nf2 = new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping: false}),\n\n    // 5. Let tm be the result of calling the ToLocalTime abstract operation (defined\n    // below) with x, the value of the [[calendar]] internal property of dateTimeFormat,\n    // and the value of the [[timeZone]] internal property of dateTimeFormat.\n        tm = ToLocalTime(x, internal['[[calendar]]'], internal['[[timeZone]]']),\n\n    // 6. Let result be the value of the [[pattern]] internal property of dateTimeFormat.\n        result = internal['[[pattern]]'],\n\n    // Need the locale minus any extensions\n        dataLocale = internal['[[dataLocale]]'],\n\n    // Need the calendar data from CLDR\n        localeData = internals.DateTimeFormat['[[localeData]]'][dataLocale].calendars,\n        ca = internal['[[calendar]]'];\n\n    // 7. For each row of Table 3, except the header row, do:\n    for (var p in dateTimeComponents) {\n        // a. If dateTimeFormat has an internal property with the name given in the\n        //    Property column of the row, then:\n        if (hop.call(internal, '[['+ p +']]')) {\n            var\n            // Assigned values below\n                pm, fv,\n\n            //   i. Let p be the name given in the Property column of the row.\n            //  ii. Let f be the value of the [[<p>]] internal property of dateTimeFormat.\n                f = internal['[['+ p +']]'],\n\n            // iii. Let v be the value of tm.[[<p>]].\n                v = tm['[['+ p +']]'];\n\n            //  iv. If p is \"year\" and v  0, then let v be 1 - v.\n            if (p === 'year' && v <= 0)\n                v = 1 - v;\n\n            //   v. If p is \"month\", then increase v by 1.\n            else if (p === 'month')\n                v++;\n\n            //  vi. If p is \"hour\" and the value of the [[hour12]] internal property of\n            //      dateTimeFormat is true, then\n            else if (p === 'hour' && internal['[[hour12]]'] === true) {\n                // 1. Let v be v modulo 12.\n                v = v % 12;\n\n                // 2. If v is equal to the value of tm.[[<p>]], then let pm be false; else\n                //    let pm be true.\n                pm = v !== tm['[['+ p +']]'];\n\n                // 3. If v is 0 and the value of the [[hourNo0]] internal property of\n                //    dateTimeFormat is true, then let v be 12.\n                if (v === 0 && internal['[[hourNo0]]'] === true)\n                    v = 12;\n            }\n\n            // vii. If f is \"numeric\", then\n            if (f === 'numeric')\n                // 1. Let fv be the result of calling the FormatNumber abstract operation\n                //    (defined in 11.3.2) with arguments nf and v.\n                fv = FormatNumber(nf, v);\n\n            // viii. Else if f is \"2-digit\", then\n            else if (f === '2-digit') {\n                // 1. Let fv be the result of calling the FormatNumber abstract operation\n                //    with arguments nf2 and v.\n                fv = FormatNumber(nf2, v);\n\n                // 2. If the length of fv is greater than 2, let fv be the substring of fv\n                //    containing the last two characters.\n                if (fv.length > 2)\n                    fv = fv.slice(-2);\n            }\n\n            // ix. Else if f is \"narrow\", \"short\", or \"long\", then let fv be a String\n            //     value representing f in the desired form; the String value depends upon\n            //     the implementation and the effective locale and calendar of\n            //     dateTimeFormat. If p is \"month\", then the String value may also depend\n            //     on whether dateTimeFormat has a [[day]] internal property. If p is\n            //     \"timeZoneName\", then the String value may also depend on the value of\n            //     the [[inDST]] field of tm.\n            else if (f in dateWidths) {\n                switch (p) {\n                    case 'month':\n                        fv = resolveDateString(localeData, ca, 'months', f, tm['[['+ p +']]']);\n                        break;\n\n                    case 'weekday':\n                        try {\n                            fv = resolveDateString(localeData, ca, 'days', f, tm['[['+ p +']]']);\n                            // fv = resolveDateString(ca.days, f)[tm['[['+ p +']]']];\n                        } catch (e) {\n                            throw new Error('Could not find weekday data for locale '+locale);\n                        }\n                        break;\n\n                    case 'timeZoneName':\n                        fv = ''; // TODO\n                        break;\n\n                    // TODO: Era\n                    default:\n                        fv = tm['[['+ p +']]'];\n                }\n            }\n\n            // x. Replace the substring of result that consists of \"{\", p, and \"}\", with\n            //    fv.\n            result = result.replace('{'+ p +'}', fv);\n        }\n    }\n    // 8. If dateTimeFormat has an internal property [[hour12]] whose value is true, then\n    if (internal['[[hour12]]'] === true) {\n        // a. If pm is true, then let fv be an implementation and locale dependent String\n        //    value representing post meridiem; else let fv be an implementation and\n        //    locale dependent String value representing ante meridiem.\n        fv = resolveDateString(localeData, ca, 'dayPeriods', pm ? 'pm' : 'am');\n\n        // b. Replace the substring of result that consists of \"{ampm}\", with fv.\n        result = result.replace('{ampm}', fv);\n    }\n\n    // Restore properties of the RegExp object\n    regexpState.exp.test(regexpState.input);\n\n    // 9. Return result.\n    return result;\n}\n\n/**\n * When the ToLocalTime abstract operation is called with arguments date, calendar, and\n * timeZone, the following steps are taken:\n */\nfunction ToLocalTime(date, calendar, timeZone) {\n    // 1. Apply calendrical calculations on date for the given calendar and time zone to\n    //    produce weekday, era, year, month, day, hour, minute, second, and inDST values.\n    //    The calculations should use best available information about the specified\n    //    calendar and time zone. If the calendar is \"gregory\", then the calculations must\n    //    match the algorithms specified in ES5, 15.9.1, except that calculations are not\n    //    bound by the restrictions on the use of best available information on time zones\n    //    for local time zone adjustment and daylight saving time adjustment imposed by\n    //    ES5, 15.9.1.7 and 15.9.1.8.\n    // ###TODO###\n    var d = new Date(date),\n        m = 'get' + (timeZone || '');\n\n    // 2. Return a Record with fields [[weekday]], [[era]], [[year]], [[month]], [[day]],\n    //    [[hour]], [[minute]], [[second]], and [[inDST]], each with the corresponding\n    //    calculated value.\n    return new Record({\n        '[[weekday]]': d[m + 'Day'](),\n        '[[era]]'    : +(d[m + 'FullYear']() >= 0),\n        '[[year]]'   : d[m + 'FullYear'](),\n        '[[month]]'  : d[m + 'Month'](),\n        '[[day]]'    : d[m + 'Date'](),\n        '[[hour]]'   : d[m + 'Hours'](),\n        '[[minute]]' : d[m + 'Minutes'](),\n        '[[second]]' : d[m + 'Seconds'](),\n        '[[inDST]]'  : false // ###TODO###\n    });\n}\n\n/**\n * The function returns a new object whose properties and attributes are set as if\n * constructed by an object literal assigning to each of the following properties the\n * value of the corresponding internal property of this DateTimeFormat object (see 12.4):\n * locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day,\n * hour, minute, second, and timeZoneName. Properties whose corresponding internal\n * properties are not present are not assigned.\n */\n/* 12.3.3 */defineProperty(Intl.DateTimeFormat.prototype, 'resolvedOptions', {\n    writable: true,\n    configurable: true,\n    value: function () {\n        var prop,\n            descs = new Record(),\n            props = [\n                'locale', 'calendar', 'numberingSystem', 'timeZone', 'hour12', 'weekday',\n                'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName'\n            ],\n            internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\n        // Satisfy test 12.3_b\n        if (!internal || !internal['[[initializedDateTimeFormat]]'])\n            throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.DateTimeFormat object.');\n\n        for (var i = 0, max = props.length; i < max; i++) {\n            if (hop.call(internal, prop = '[[' + props[i] + ']]'))\n                descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n        }\n\n        return objCreate({}, descs);\n    }\n});\n\n// Sect 13 Locale Sensitive Functions of the ECMAScript Language Specification\n// ===========================================================================\n\nvar ls = Intl.__localeSensitiveProtos = {\n    Number: {},\n    Date:   {}\n};\n\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n/* 13.2.1 */ls.Number.toLocaleString = function () {\n    // Satisfy test 13.2.1_1\n    if (Object.prototype.toString.call(this) !== '[object Number]')\n        throw new TypeError('`this` value must be a number for Number.prototype.toLocaleString()');\n\n    // 1. Let x be this Number value (as defined in ES5, 15.7.4).\n    // 2. If locales is not provided, then let locales be undefined.\n    // 3. If options is not provided, then let options be undefined.\n    // 4. Let numberFormat be the result of creating a new object as if by the\n    //    expression new Intl.NumberFormat(locales, options) where\n    //    Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n    // 5. Return the result of calling the FormatNumber abstract operation\n    //    (defined in 11.3.2) with arguments numberFormat and x.\n    return FormatNumber(new NumberFormatConstructor(arguments[0], arguments[1]), this);\n};\n\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n/* 13.3.1 */ls.Date.toLocaleString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]')\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleString()');\n\n    var\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n        x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x))\n        return 'Invalid Date';\n\n    var\n    // 3. If locales is not provided, then let locales be undefined.\n        locales = arguments[0],\n\n    // 4. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"any\", and \"all\".\n        options = ToDateTimeOptions(options, 'any', 'all'),\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n        dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\n/**\n * When the toLocaleDateString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n/* 13.3.2 */ls.Date.toLocaleDateString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]')\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleDateString()');\n\n    var\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n        x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x))\n        return 'Invalid Date';\n\n    var\n    // 3. If locales is not provided, then let locales be undefined.\n        locales = arguments[0],\n\n    // 4. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"date\", and \"date\".\n        options = ToDateTimeOptions(options, 'date', 'date'),\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n        dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\n/**\n * When the toLocaleTimeString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n/* 13.3.3 */ls.Date.toLocaleTimeString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]')\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleTimeString()');\n\n    var\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n        x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x))\n        return 'Invalid Date';\n\n    var\n    // 3. If locales is not provided, then let locales be undefined.\n        locales = arguments[0],\n\n    // 4. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"time\", and \"time\".\n        options = ToDateTimeOptions(options, 'time', 'time'),\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n        dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\ndefineProperty(Intl, '__applyLocaleSensitivePrototypes', {\n    writable: true,\n    configurable: true,\n    value: function () {\n        defineProperty(Number.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Number.toLocaleString });\n        // Need this here for IE 8, to avoid the _DontEnum_ bug\n        defineProperty(Date.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Date.toLocaleString });\n\n        for (var k in ls.Date) {\n            if (hop.call(ls.Date, k))\n                defineProperty(Date.prototype, k, { writable: true, configurable: true, value: ls.Date[k] });\n        }\n    }\n});\n\n/**\n * Can't really ship a single script with data for hundreds of locales, so we provide\n * this __addLocaleData method as a means for the developer to add the data on an\n * as-needed basis\n */\ndefineProperty(Intl, '__addLocaleData', {\n    value: function (data) {\n        if (!IsStructurallyValidLanguageTag(data.locale))\n            throw new Error(\"Object passed doesn't identify itself with a valid language tag\");\n\n        addLocaleData(data, data.locale);\n    }\n});\n\nfunction addLocaleData (data, tag) {\n    // Both NumberFormat and DateTimeFormat require number data, so throw if it isn't present\n    if (!data.number)\n        throw new Error(\"Object passed doesn't contain locale data for Intl.NumberFormat\");\n\n    var locale,\n        locales = [ tag ],\n        parts   = tag.split('-');\n\n    // Create fallbacks for locale data with scripts, e.g. Latn, Hans, Vaii, etc\n    if (parts.length > 2 && parts[1].length === 4)\n        arrPush.call(locales, parts[0] + '-' + parts[2]);\n\n    while (locale = arrShift.call(locales)) {\n        // Add to NumberFormat internal properties as per 11.2.3\n        arrPush.call(internals.NumberFormat['[[availableLocales]]'], locale);\n        internals.NumberFormat['[[localeData]]'][locale] = data.number;\n\n        // ...and DateTimeFormat internal properties as per 12.2.3\n        if (data.date) {\n            data.date.nu = data.number.nu;\n            arrPush.call(internals.DateTimeFormat['[[availableLocales]]'], locale);\n            internals.DateTimeFormat['[[localeData]]'][locale] = data.date;\n        }\n    }\n\n    // If this is the first set of locale data added, make it the default\n    if (defaultLocale === undefined)\n        defaultLocale = tag;\n\n    // 11.3 (the NumberFormat prototype object is an Intl.NumberFormat instance)\n    if (!numberFormatProtoInitialised) {\n        InitializeNumberFormat(Intl.NumberFormat.prototype);\n        numberFormatProtoInitialised = true;\n    }\n\n    // 11.3 (the NumberFormat prototype object is an Intl.NumberFormat instance)\n    if (data.date && !dateTimeFormatProtoInitialised) {\n        InitializeDateTimeFormat(Intl.DateTimeFormat.prototype);\n        dateTimeFormatProtoInitialised = true;\n    }\n}\n\n// Helper functions\n// ================\n\n/**\n * A function to deal with the inaccuracy of calculating log10 in pre-ES6\n * JavaScript environments. Math.log(num) / Math.LN10 was responsible for\n * causing issue #62.\n */\nfunction log10Floor (n) {\n    // ES6 provides the more accurate Math.log10\n    if (typeof Math.log10 === 'function')\n        return Math.floor(Math.log10(n));\n\n    var x = Math.round(Math.log(n) * Math.LOG10E);\n    return x - (Number('1e' + x) > n);\n}\n\n/**\n * A merge of the Intl.{Constructor}.supportedLocalesOf functions\n * To make life easier, the function should be bound to the constructor's internal\n * properties object.\n */\nfunction supportedLocalesOf(locales) {\n    /*jshint validthis:true */\n\n    // Bound functions only have the `this` value altered if being used as a constructor,\n    // this lets us imitate a native function that has no constructor\n    if (!hop.call(this, '[[availableLocales]]'))\n        throw new TypeError('supportedLocalesOf() is not a constructor');\n\n    var\n    // Create an object whose props can be used to restore the values of RegExp props\n        regexpState = createRegExpRestore(),\n\n    // 1. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n    // 2. Let availableLocales be the value of the [[availableLocales]] internal\n    //    property of the standard built-in object that is the initial value of\n    //    Intl.NumberFormat.\n\n        availableLocales = this['[[availableLocales]]'],\n\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n        requestedLocales = CanonicalizeLocaleList(locales);\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // 4. Return the result of calling the SupportedLocales abstract operation\n    //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n    //    and options.\n    return SupportedLocales(availableLocales, requestedLocales, options);\n}\n\n/**\n * Returns a string for a date component, resolved using multiple inheritance as specified\n * as specified in the Unicode Technical Standard 35.\n */\nfunction resolveDateString(data, ca, component, width, key) {\n    // From http://www.unicode.org/reports/tr35/tr35.html#Multiple_Inheritance:\n    // 'In clearly specified instances, resources may inherit from within the same locale.\n    //  For example, ... the Buddhist calendar inherits from the Gregorian calendar.'\n    var obj = data[ca] && data[ca][component]\n                ? data[ca][component]\n                : data.gregory[component],\n\n        // \"sideways\" inheritance resolves strings when a key doesn't exist\n        alts = {\n            narrow: ['short', 'long'],\n            short:  ['long', 'narrow'],\n            long:   ['short', 'narrow']\n        },\n\n        //\n        resolved = hop.call(obj, width)\n                  ? obj[width]\n                  : hop.call(obj, alts[width][0])\n                      ? obj[alts[width][0]]\n                      : obj[alts[width][1]];\n\n    // `key` wouldn't be specified for components 'dayPeriods'\n    return key != null ? resolved[key] : resolved;\n}\n\n/**\n * A map that doesn't contain Object in its prototype chain\n */\nRecord.prototype = objCreate(null);\nfunction Record (obj) {\n    // Copy only own properties over unless this object is already a Record instance\n    for (var k in obj) {\n        if (obj instanceof Record || hop.call(obj, k))\n            defineProperty(this, k, { value: obj[k], enumerable: true, writable: true, configurable: true });\n    }\n}\n\n/**\n * An ordered list\n */\nList.prototype = objCreate(null);\nfunction List() {\n    defineProperty(this, 'length', { writable:true, value: 0 });\n\n    if (arguments.length)\n        arrPush.apply(this, arrSlice.call(arguments));\n}\n\n/**\n * Constructs a regular expression to restore tainted RegExp properties\n */\nfunction createRegExpRestore () {\n    var esc = /[.?*+^$[\\]\\\\(){}|-]/g,\n        lm  = RegExp.lastMatch || '',\n        ml  = RegExp.multiline ? 'm' : '',\n        ret = { input: RegExp.input },\n        reg = new List(),\n        has = false,\n        cap = {};\n\n    // Create a snapshot of all the 'captured' properties\n    for (var i = 1; i <= 9; i++)\n        has = (cap['$'+i] = RegExp['$'+i]) || has;\n\n    // Now we've snapshotted some properties, escape the lastMatch string\n    lm = lm.replace(esc, '\\\\$&');\n\n    // If any of the captured strings were non-empty, iterate over them all\n    if (has) {\n        for (var i = 1; i <= 9; i++) {\n            var m = cap['$'+i];\n\n            // If it's empty, add an empty capturing group\n            if (!m)\n                lm = '()' + lm;\n\n            // Else find the string in lm and escape & wrap it to capture it\n            else {\n                m = m.replace(esc, '\\\\$&');\n                lm = lm.replace(m, '(' + m + ')');\n            }\n\n            // Push it to the reg and chop lm to make sure further groups come after\n            arrPush.call(reg, lm.slice(0, lm.indexOf('(') + 1));\n            lm = lm.slice(lm.indexOf('(') + 1);\n        }\n    }\n\n    // Create the regular expression that will reconstruct the RegExp properties\n    ret.exp = new RegExp(arrJoin.call(reg, '') + lm, ml);\n\n    return ret;\n}\n\n/**\n * Convert only a-z to uppercase as per section 6.1 of the spec\n */\nfunction toLatinUpperCase (str) {\n    var i = str.length;\n\n    while (i--) {\n        var ch = str.charAt(i);\n\n        if (ch >= \"a\" && ch <= \"z\")\n            str = str.slice(0, i) + ch.toUpperCase() + str.slice(i+1);\n    }\n\n    return str;\n}\n\n/**\n * Mimics ES5's abstract ToObject() function\n */\nfunction toObject (arg) {\n    if (arg == null)\n        throw new TypeError('Cannot convert null or undefined to object');\n\n    return Object(arg);\n}\n\n/**\n * Returns \"internal\" properties for an object\n */\nfunction getInternalProperties (obj) {\n    if (hop.call(obj, '__getInternalProperties'))\n        return obj.__getInternalProperties(secret);\n    else\n        return objCreate(null);\n}\n\nexport default Intl;\n","/* jslint esnext: true */\n\nimport IntlPolyfill from \"./core\";\n\n// hack to export the polyfill as global Intl if needed\nif (!this.Intl) {\n    this.Intl = IntlPolyfill;\n    IntlPolyfill.__applyLocaleSensitivePrototypes();\n}\n\nexport default IntlPolyfill;\n"]}