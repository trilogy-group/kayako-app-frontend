{"version":3,"sources":["/src/cldr.js","/src/core.js","/src/exp.js","/src/main.js"],"names":["$$cldr$$isDateFormatOnly","obj","i","$$cldr$$tmKeys","length","hasOwnProperty","$$cldr$$isTimeFormatOnly","$$cldr$$dtKeys","$$cldr$$createDateTimeFormat","format","$$cldr$$unwantedDTCs","test","formatObj","pattern","replace","$$cldr$$expDTComponents","$0","charAt","weekday","$$cldr$$dtcLengthMap","era","year","month","day","hour","minute","second","timeZoneName","literal","indexOf","hour12","pattern12","$$cldr$$createDateTimeFormats","formats","expandFormat","key","M","Array","match","E","join","computed","j","availableFormats","timeFormats","dateFormats","order","medium","result","timeRelatedFormats","dateRelatedFormats","push","$$core$$IsStructurallyValidLanguageTag","locale","$$exp$$expBCP47Syntax","$$exp$$expVariantDupes","$$exp$$expSingletonDupes","$$core$$CanonicalizeLanguageTag","parts","toLowerCase","split","max","toUpperCase","slice","$$core$$arrJoin","call","$$exp$$expExtSequences","sort","RegExp","source","$$core$$hop","$$core$$redundantTags","tags","subtags","extLang","$$core$$arrSlice","$$core$$DefaultLocale","$$core$$defaultLocale","$$core$$IsWellFormedCurrencyCode","currency","c","String","normalized","$$core$$toLatinUpperCase","$$core$$expCurrencyCode","$$core$$CanonicalizeLocaleList","locales","undefined","$$core$$List","seen","O","$$core$$toObject","len","k","Pk","kPresent","kValue","TypeError","tag","RangeError","$$core$$arrIndexOf","$$core$$BestAvailableLocale","availableLocales","candidate","pos","lastIndexOf","substring","$$core$$LookupMatcher","requestedLocales","availableLocale","noExtensionsLocale","$$core$$expUnicodeExSeq","$$core$$Record","extension","extensionIndex","$$core$$BestFitMatcher","$$core$$ResolveLocale","options","relevantExtensionKeys","localeData","ReferenceError","matcher","r","foundLocale","prototype","extensionSubtags","extensionSubtagsLength","supportedExtension","foundLocaleData","keyLocaleData","value","supportedExtensionAddition","keyPos","requestedValue","valuePos","optionsValue","preExtension","postExtension","$$core$$LookupSupportedLocales","subset","subsetArray","$$core$$BestFitSupportedLocales","$$core$$SupportedLocales","localeMatcher","P","writable","configurable","$$core$$GetOption","property","type","values","fallback","Boolean","$$core$$GetNumberOption","minimum","maximum","Number","isNaN","Math","floor","$$core$$NumberFormatConstructor","arguments","this","$$core$$Intl","$$core$$InitializeNumberFormat","NumberFormat","numberFormat","internal","$$core$$getInternalProperties","regexpState","$$core$$createRegExpRestore","$$core$$secret","opt","$$core$$internals","dataLocale","s","cDigits","$$core$$CurrencyDigits","cd","mnid","mnfdDefault","mnfd","mxfdDefault","mxfd","mnsd","minimumSignificantDigits","mxsd","maximumSignificantDigits","g","dataLocaleData","patterns","stylePatterns","positivePattern","negativePattern","$$core$$es3","$$core$$GetFormatNumber","exp","input","$$core$$currencyMinorUnits","F","$$core$$FormatNumber","bf","$$core$$fnBind","x","n","nums","data","ild","symbols","latn","negative","isFinite","nan","infinity","$$core$$ToRawPrecision","$$core$$ToRawFixed","$$core$$numSys","digits","digit","decimal","igr","pgSize","primaryGroupSize","sgSize","secondaryGroupSize","groups","end","idx","start","group","cData","currencies","minPrecision","maxPrecision","p","m","e","$$core$$log10Floor","abs","f","round","LN10","cut","minInteger","minFraction","maxFraction","toFixed","z","$$core$$DateTimeFormatConstructor","$$core$$InitializeDateTimeFormat","DateTimeFormat","dateTimeFormat","$$core$$ToDateTimeOptions","tz","timeZone","prop","$$core$$dateTimeComponents","bestFormat","$$core$$ToDateTimeFormats","$$core$$BasicFormatMatcher","$$core$$BestFitFormatMatcher","hr12","hourNo0","$$core$$GetFormatDateTime","Object","toString","required","defaults","opt2","create","$$core$$objCreate","needDefaults","$$core$$calculateScore","bestFit","diffDataTypePenalty","removalPenalty","additionPenalty","longLessPenalty","longMorePenalty","shortLessPenalty","shortMorePenalty","bestScore","Infinity","score","optionsProp","formatProp","optionsPropIndex","formatPropIndex","delta","min","Date","now","$$core$$FormatDateTime","__getInternalProperties","nf","useGrouping","nf2","minimumIntegerDigits","tm","$$core$$ToLocalTime","calendars","ca","pm","fv","v","$$core$$dateWidths","$$core$$resolveDateString","Error","date","calendar","d","[[weekday]]","[[era]]","[[year]]","[[month]]","[[day]]","[[hour]]","[[minute]]","[[second]]","[[inDST]]","$$core$$addLocaleData","number","$$core$$arrShift","nu","$$core$$numberFormatProtoInitialised","$$core$$dateTimeFormatProtoInitialised","log10","log","LOG10E","$$core$$supportedLocalesOf","component","width","gregory","alts","narrow","short","long","resolved","enumerable","apply","esc","lm","lastMatch","ml","multiline","ret","reg","has","cap","str","ch","arg","$$exp$$extlang","$$exp$$singleton","$$exp$$irregular","$$exp$$regular","$$exp$$language","$$exp$$script","$$exp$$region","$$exp$$variant","$$exp$$extension","$$exp$$privateuse","$$exp$$langtag","$$exp$$grandfathered","sentinel","defineProperty","$$core$$realDefineProp","__defineGetter__","name","desc","get","search","t","proto","props","concat","shift","unshift","Function","bind","thisObj","fn","args","a","$$core$$arrConcat","random","art-lojban","i-ami","i-bnn","i-hak","i-klingon","i-lux","i-navajo","i-pwn","i-tao","i-tay","i-tsu","no-bok","no-nyn","sgn-BE-FR","sgn-BE-NL","sgn-CH-DE","zh-guoyu","zh-hakka","zh-min-nan","zh-xiang","sgn-BR","sgn-CO","sgn-DE","sgn-DK","sgn-ES","sgn-FR","sgn-GB","sgn-GR","sgn-IE","sgn-IT","sgn-JP","sgn-MX","sgn-NI","sgn-NL","sgn-NO","sgn-PT","sgn-SE","sgn-US","sgn-ZA","zh-cmn","zh-cmn-Hans","zh-cmn-Hant","zh-gan","zh-wuu","zh-yue","BU","DD","FX","TP","YD","ZR","heploc","in","iw","ji","jw","mo","ayx","bjd","ccq","cjr","cka","cmk","drh","drw","gav","hrr","ibi","kgh","lcq","mst","myt","sca","tie","tkk","tlw","tnf","ybd","yma","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","aed","aen","afb","afg","ajp","apc","apd","arb","arq","ars","ary","arz","ase","asf","asp","asq","asw","auz","avl","ayh","ayl","ayn","ayp","bbz","bfi","bfk","bjn","bog","bqn","bqy","btj","bve","bvl","bvu","bzs","cdo","cds","cjy","cmn","coa","cpx","csc","csd","cse","csf","csg","csl","csn","csq","csr","czh","czo","doq","dse","dsl","dup","ecs","esl","esn","eso","eth","fcs","fse","fsl","fss","gan","gds","gom","gse","gsg","gsm","gss","gus","hab","haf","hak","hds","hji","hks","hos","hps","hsh","hsl","hsn","icl","ils","inl","ins","ise","isg","isr","jak","jax","jcs","jhs","jls","jos","jsl","jus","kgi","knn","kvb","kvk","kvr","kxd","lbs","lce","lcf","liw","lls","lsg","lsl","lso","lsp","lst","lsy","ltg","lvs","lzh","mdl","meo","mfa","mfb","mfs","mnp","mqg","mre","msd","msi","msr","mui","mzc","mzg","mzy","nbs","ncs","nsi","nsl","nsp","nsr","nzs","okl","orn","ors","pel","pga","pks","prl","prz","psc","psd","pse","psg","psl","pso","psp","psr","pys","rms","rsi","rsl","sdl","sfb","sfs","sgg","sgx","shu","slf","sls","sqk","sqs","ssh","ssp","ssr","svk","swc","swh","swl","syy","tmw","tse","tsm","tsq","tss","tsy","tza","ugn","ugy","ukl","uks","urk","uzn","uzs","vgt","vkk","vkt","vsi","vsl","vsv","wuu","xki","xml","xmm","xms","yds","ysl","yue","zib","zlm","zmi","zsl","zsm","BHD","BYR","XOF","BIF","XAF","CLF","CLP","KMF","DJF","XPF","GNF","ISK","IQD","JPY","JOD","KRW","KWD","LYD","OMR","PYG","RWF","TND","UGX","UYI","VUV","VND","[[availableLocales]]","[[relevantExtensionKeys]]","[[localeData]]","arab","arabext","bali","beng","deva","fullwide","gujr","guru","hanidec","khmr","knda","laoo","limb","mlym","mong","mymr","orya","tamldec","telu","thai","tibt","descs","$$core$$ls","__localeSensitiveProtos","toLocaleString","toLocaleDateString","toLocaleTimeString","Intl","$$core$$default","__applyLocaleSensitivePrototypes"],"mappings":"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AO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,MAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,MAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,MAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,OAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,MAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,MACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,MAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OACnFC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,MAAO,OAASC,KAAO,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","file":"intl.js","sourcesContent":["/* jshint esnext: true, laxbreak:true */\n\n/**\n* Defines regular expressions for various operations related to the BCP 47 syntax,\n* as defined at http://tools.ietf.org/html/bcp47#section-2.1\n*/\n\nvar\n    // extlang       = 3ALPHA              ; selected ISO 639 codes\n    //                 *2(\"-\" 3ALPHA)      ; permanently reserved\n    extlang = '[a-z]{3}(?:-[a-z]{3}){0,2}',\n\n    // language      = 2*3ALPHA            ; shortest ISO 639 code\n    //                 [\"-\" extlang]       ; sometimes followed by\n    //                                     ; extended language subtags\n    //               / 4ALPHA              ; or reserved for future use\n    //               / 5*8ALPHA            ; or registered language subtag\n    language = '(?:[a-z]{2,3}(?:-' + extlang + ')?|[a-z]{4}|[a-z]{5,8})',\n\n    // script        = 4ALPHA              ; ISO 15924 code\n    script = '[a-z]{4}',\n\n    // region        = 2ALPHA              ; ISO 3166-1 code\n    //               / 3DIGIT              ; UN M.49 code\n    region = '(?:[a-z]{2}|\\\\d{3})',\n\n    // variant       = 5*8alphanum         ; registered variants\n    //               / (DIGIT 3alphanum)\n    variant = '(?:[a-z0-9]{5,8}|\\\\d[a-z0-9]{3})',\n\n    //                                     ; Single alphanumerics\n    //                                     ; \"x\" reserved for private use\n    // singleton     = DIGIT               ; 0 - 9\n    //               / %x41-57             ; A - W\n    //               / %x59-5A             ; Y - Z\n    //               / %x61-77             ; a - w\n    //               / %x79-7A             ; y - z\n    singleton = '[0-9a-wy-z]',\n\n    // extension     = singleton 1*(\"-\" (2*8alphanum))\n    extension = singleton + '(?:-[a-z0-9]{2,8})+',\n\n    // privateuse    = \"x\" 1*(\"-\" (1*8alphanum))\n    privateuse = 'x(?:-[a-z0-9]{1,8})+',\n\n    // irregular     = \"en-GB-oed\"         ; irregular tags do not match\n    //               / \"i-ami\"             ; the 'langtag' production and\n    //               / \"i-bnn\"             ; would not otherwise be\n    //               / \"i-default\"         ; considered 'well-formed'\n    //               / \"i-enochian\"        ; These tags are all valid,\n    //               / \"i-hak\"             ; but most are deprecated\n    //               / \"i-klingon\"         ; in favor of more modern\n    //               / \"i-lux\"             ; subtags or subtag\n    //               / \"i-mingo\"           ; combination\n    //               / \"i-navajo\"\n    //               / \"i-pwn\"\n    //               / \"i-tao\"\n    //               / \"i-tay\"\n    //               / \"i-tsu\"\n    //               / \"sgn-BE-FR\"\n    //               / \"sgn-BE-NL\"\n    //               / \"sgn-CH-DE\"\n    irregular = '(?:en-GB-oed'\n              + '|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)'\n              + '|sgn-(?:BE-FR|BE-NL|CH-DE))',\n\n    // regular       = \"art-lojban\"        ; these tags match the 'langtag'\n    //               / \"cel-gaulish\"       ; production, but their subtags\n    //               / \"no-bok\"            ; are not extended language\n    //               / \"no-nyn\"            ; or variant subtags: their meaning\n    //               / \"zh-guoyu\"          ; is defined by their registration\n    //               / \"zh-hakka\"          ; and all of these are deprecated\n    //               / \"zh-min\"            ; in favor of a more modern\n    //               / \"zh-min-nan\"        ; subtag or sequence of subtags\n    //               / \"zh-xiang\"\n    regular = '(?:art-lojban|cel-gaulish|no-bok|no-nyn'\n            + '|zh-(?:guoyu|hakka|min|min-nan|xiang))',\n\n    // grandfathered = irregular           ; non-redundant tags registered\n    //               / regular             ; during the RFC 3066 era\n    grandfathered = '(?:' + irregular + '|' + regular + ')',\n\n    // langtag       = language\n    //                 [\"-\" script]\n    //                 [\"-\" region]\n    //                 *(\"-\" variant)\n    //                 *(\"-\" extension)\n    //                 [\"-\" privateuse]\n    langtag = language + '(?:-' + script + ')?(?:-' + region + ')?(?:-'\n            + variant + ')*(?:-' + extension + ')*(?:-' + privateuse + ')?';\n\n// Language-Tag  = langtag             ; normal language tags\n//               / privateuse          ; private use tag\n//               / grandfathered       ; grandfathered tags\nexport var expBCP47Syntax = RegExp('^(?:'+langtag+'|'+privateuse+'|'+grandfathered+')$', 'i');\n\n// Match duplicate variants in a language tag\nexport var expVariantDupes = RegExp('^(?!x).*?-('+variant+')-(?:\\\\w{4,8}-(?!x-))*\\\\1\\\\b', 'i');\n\n// Match duplicate singletons in a language tag (except in private use)\nexport var expSingletonDupes = RegExp('^(?!x).*?-('+singleton+')-(?:\\\\w+-(?!x-))*\\\\1\\\\b', 'i');\n\n// Match all extension sequences\nexport var expExtSequences = RegExp('-'+extension, 'ig');\n","/* jslint esnext: true */\n\n// Match these datetime components in a CLDR pattern, except those in single quotes\nvar expDTComponents = /(?:[Eec]{1,6}|G{1,5}|(?:[yYu]+|U{1,5})|[ML]{1,5}|d{1,2}|a|[hkHK]{1,2}|m{1,2}|s{1,2}|z{1,4})(?=([^']*'[^']*')*[^']*$)/g;\n\n// Skip over patterns with these datetime components\nvar unwantedDTCs = /[QxXVOvZASjgFDwWIQqH]/;\n\n// Maps the number of characters in a CLDR pattern to the specification\nvar dtcLengthMap = {\n        month:   [ 'numeric', '2-digit', 'short', 'long', 'narrow' ],\n        weekday: [ 'short', 'short', 'short', 'long', 'narrow' ],\n        era:     [ 'short', 'short', 'short', 'long', 'narrow' ]\n    };\n\nvar dtKeys = [\"weekday\", \"era\", \"year\", \"month\", \"day\"];\nvar tmKeys = [\"hour\", \"minute\", \"second\", \"timeZoneName\"];\n\nfunction isDateFormatOnly(obj) {\n    for (var i = 0; i < tmKeys.length; i += 1) {\n        if (obj.hasOwnProperty(tmKeys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isTimeFormatOnly(obj) {\n    for (var i = 0; i < dtKeys.length; i += 1) {\n        if (obj.hasOwnProperty(dtKeys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Converts the CLDR availableFormats into the objects and patterns required by\n * the ECMAScript Internationalization API specification.\n */\nexport function createDateTimeFormat(format) {\n    if (unwantedDTCs.test(format))\n        return undefined;\n\n    var formatObj = {};\n\n    // Replace the pattern string with the one required by the specification, whilst\n    // at the same time evaluating it for the subsets and formats\n    formatObj.pattern = format.replace(expDTComponents, function ($0) {\n        // See which symbol we're dealing with\n        switch ($0.charAt(0)) {\n            case 'E':\n            case 'e':\n            case 'c':\n                formatObj.weekday = dtcLengthMap.weekday[$0.length-1];\n                return '{weekday}';\n\n            // Not supported yet\n            case 'G':\n                formatObj.era = dtcLengthMap.era[$0.length-1];\n                return '{era}';\n\n            case 'y':\n            case 'Y':\n            case 'u':\n            case 'U':\n                formatObj.year = $0.length === 2 ? '2-digit' : 'numeric';\n                return '{year}';\n\n            case 'M':\n            case 'L':\n                formatObj.month = dtcLengthMap.month[$0.length-1];\n                return '{month}';\n\n            case 'd':\n                formatObj.day = $0.length === 2 ? '2-digit' : 'numeric';\n                return '{day}';\n\n            case 'a':\n                return '{ampm}';\n\n            case 'h':\n            case 'H':\n            case 'k':\n            case 'K':\n                formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n                return '{hour}';\n\n            case 'm':\n                formatObj.minute = $0.length === 2 ? '2-digit' : 'numeric';\n                return '{minute}';\n\n            case 's':\n                formatObj.second = $0.length === 2 ? '2-digit' : 'numeric';\n                return '{second}';\n\n            case 'z':\n                formatObj.timeZoneName = $0.length < 4 ? 'short' : 'long';\n                return '{timeZoneName}';\n        }\n    });\n\n    // From http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns:\n    //  'In patterns, two single quotes represents a literal single quote, either\n    //   inside or outside single quotes. Text within single quotes is not\n    //   interpreted in any way (except for two adjacent single quotes).'\n    formatObj.pattern = formatObj.pattern.replace(/'([^']*)'/g, function ($0, literal) {\n        return literal ? literal : \"'\";\n    });\n\n    if (formatObj.pattern.indexOf('{ampm}') > -1) {\n        formatObj.hour12 = true;\n        formatObj.pattern12 = formatObj.pattern;\n        formatObj.pattern = formatObj.pattern.replace('{ampm}', '').replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n    }\n\n    return formatObj;\n}\n\n/**\n * Processes DateTime formats from CLDR to an easier-to-parse format.\n * the result of this operation should be cached the first time a particular\n * calendar is analyzed.\n *\n * The specification requires we support at least the following subsets of\n * date/time components:\n *\n *   - 'weekday', 'year', 'month', 'day', 'hour', 'minute', 'second'\n *   - 'weekday', 'year', 'month', 'day'\n *   - 'year', 'month', 'day'\n *   - 'year', 'month'\n *   - 'month', 'day'\n *   - 'hour', 'minute', 'second'\n *   - 'hour', 'minute'\n *\n * We need to cherry pick at least these subsets from the CLDR data and convert\n * them into the pattern objects used in the ECMA-402 API.\n */\nexport function createDateTimeFormats(formats) {\n    var availableFormats = formats.availableFormats;\n    var timeFormats = formats.timeFormats;\n    var dateFormats = formats.dateFormats;\n    var order = formats.medium;\n    var result = [];\n    var key, format, computed, i, j;\n    var timeRelatedFormats = [];\n    var dateRelatedFormats = [];\n\n    function expandFormat(key, pattern) {\n        // Expand component lengths if necessary, as allowed in the LDML spec\n        // Get the lengths of 'M' and 'E' substrings in the date pattern\n        // as arrays that can be joined to create a new substring\n        var M = new Array((key.match(/M/g)||[]).length + 1);\n        var E = new Array((key.match(/E/g)||[]).length + 1);\n\n        // note from caridy: I'm not sure we really need this, seems to be\n        //                   useless since it relies on the keys from CLDR\n        //                   instead of the actual format pattern, but I'm not sure.\n        if (M.length > 2)\n            pattern = pattern.replace(/(M|L)+/, M.join('$1'));\n\n        if (E.length > 2)\n            pattern = pattern.replace(/([Eec])+/, E.join('$1'));\n\n        return pattern;\n    }\n\n    // Map available (custom) formats into a pattern for createDateTimeFormats\n    for (key in availableFormats) {\n        if (availableFormats.hasOwnProperty(key)) {\n            format = expandFormat(key, availableFormats[key]);\n            computed = createDateTimeFormat(format);\n            if (computed) {\n                result.push(computed);\n                // in some cases, the format is only displaying date specific props\n                // or time specific props, in which case we need to also produce the\n                // combined formats.\n                if (isDateFormatOnly(computed)) {\n                    dateRelatedFormats.push(format);\n                } else if (isTimeFormatOnly(computed)) {\n                    timeRelatedFormats.push(format);\n                }\n            }\n        }\n    }\n\n    // combine custom time and custom date formats when they are orthogonals to complete the\n    // formats supported by browsers by relying on the value of \"formats.medium\" which defines\n    // how to join custom formats into a single pattern.\n    for (i = 0; i < timeRelatedFormats.length; i += 1) {\n        for (j = 0; j < dateRelatedFormats.length; j += 1) {\n            format = order\n                .replace('{0}', timeRelatedFormats[i])\n                .replace('{1}', dateRelatedFormats[j])\n                .replace(/^[,\\s]+|[,\\s]+$/gi, '');\n            computed = createDateTimeFormat(format);\n            if (computed) {\n                result.push(computed);\n            }\n        }\n    }\n\n    // Map time formats into a pattern for createDateTimeFormats\n    for (key in timeFormats) {\n        if (timeFormats.hasOwnProperty(key)) {\n            format = expandFormat(key, timeFormats[key]);\n            computed = createDateTimeFormat(format);\n            if (computed) {\n                result.push(computed);\n            }\n        }\n    }\n\n    // Map date formats into a pattern for createDateTimeFormats\n    for (key in dateFormats) {\n        if (dateFormats.hasOwnProperty(key)) {\n            format = expandFormat(key, dateFormats[key]);\n            computed = createDateTimeFormat(format);\n            if (computed) {\n                result.push(computed);\n            }\n        }\n    }\n\n    return result;\n}\n","/**\n * @license Copyright 2013 Andy Earnshaw, MIT License\n *\n * Implements the ECMAScript Internationalization API in ES5-compatible environments,\n * following the ECMA-402 specification as closely as possible\n *\n * ECMA-402: http://ecma-international.org/ecma-402/1.0/\n *\n * CLDR format locale data should be provided using IntlPolyfill.__addLocaleData().\n */\n/*jshint esnext: true, proto:true, eqnull:true, boss:true, laxbreak:true, newcap:false, shadow:true, funcscope:true */\n\nimport {\n    expBCP47Syntax,\n    expExtSequences,\n    expVariantDupes,\n    expSingletonDupes\n} from './exp';\n\nimport {\n    createDateTimeFormats\n} from \"./cldr\";\n\nvar Intl = {},\n\n    realDefineProp = (function () {\n        var sentinel = {};\n        try {\n            Object.defineProperty(sentinel, 'a', {});\n            return 'a' in sentinel;\n        } catch (e) {\n            return false;\n        }\n    })(),\n\n    // Need a workaround for getters in ES3\n    es3  = !realDefineProp && !Object.prototype.__defineGetter__,\n\n    // We use this a lot (and need it for proto-less objects)\n    hop = Object.prototype.hasOwnProperty,\n\n    // Naive defineProperty for compatibility\n    defineProperty = realDefineProp ? Object.defineProperty : function (obj, name, desc) {\n        if ('get' in desc && obj.__defineGetter__)\n            obj.__defineGetter__(name, desc.get);\n\n        else if (!hop.call(obj, name) || 'value' in desc)\n            obj[name] = desc.value;\n    },\n\n    // Array.prototype.indexOf, as good as we need it to be\n    arrIndexOf = Array.prototype.indexOf || function (search) {\n        /*jshint validthis:true */\n        var t = this;\n        if (!t.length)\n            return -1;\n\n        for (var i = arguments[1] || 0, max = t.length; i < max; i++) {\n            if (t[i] === search)\n                return i;\n        }\n\n        return -1;\n    },\n\n    // Create an object with the specified prototype (2nd arg required for Record)\n    objCreate = Object.create || function (proto, props) {\n        var obj;\n\n        function F() {}\n        F.prototype = proto;\n        obj = new F();\n\n        for (var k in props) {\n            if (hop.call(props, k))\n                defineProperty(obj, k, props[k]);\n        }\n\n        return obj;\n    },\n\n    // Snapshot some (hopefully still) native built-ins\n    arrSlice  = Array.prototype.slice,\n    arrConcat = Array.prototype.concat,\n    arrPush   = Array.prototype.push,\n    arrJoin   = Array.prototype.join,\n    arrShift  = Array.prototype.shift,\n    arrUnshift= Array.prototype.unshift,\n\n    // Naive Function.prototype.bind for compatibility\n    fnBind = Function.prototype.bind || function (thisObj) {\n        var fn = this,\n            args = arrSlice.call(arguments, 1);\n\n        // All our (presently) bound functions have either 1 or 0 arguments. By returning\n        // different function signatures, we can pass some tests in ES3 environments\n        if (fn.length === 1) {\n            return function (a) {\n                return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n            };\n        }\n        else {\n            return function () {\n                return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n            };\n        }\n    },\n\n    // Default locale is the first-added locale data for us\n    defaultLocale,\n\n    // Object housing internal properties for constructors\n    internals = objCreate(null),\n\n    // Keep internal properties internal\n    secret = Math.random(),\n\n    // An object map of date component keys, saves using a regex later\n    dateWidths = objCreate(null, { narrow:{}, short:{}, long:{} }),\n\n    // Each constructor prototype should be an instance of the constructor itself, but we\n    // can't initialise them as such until some locale data has been added, so this is how\n    // we keep track\n    numberFormatProtoInitialised = false,\n    dateTimeFormatProtoInitialised = false,\n\n    // Some regular expressions we're using\n    expCurrencyCode = /^[A-Z]{3}$/,\n    expUnicodeExSeq = /-u(?:-[0-9a-z]{2,8})+/gi, // See `extension` below\n\n    // IANA Subtag Registry redundant tag and subtag maps\n    redundantTags = {\n        tags: {\n            \"art-lojban\":   \"jbo\",       \"i-ami\":        \"ami\",       \"i-bnn\":       \"bnn\",  \"i-hak\":      \"hak\",\n            \"i-klingon\":    \"tlh\",       \"i-lux\":        \"lb\",        \"i-navajo\":    \"nv\",   \"i-pwn\":      \"pwn\",\n            \"i-tao\":        \"tao\",       \"i-tay\":        \"tay\",       \"i-tsu\":       \"tsu\",  \"no-bok\":     \"nb\",\n            \"no-nyn\":       \"nn\",        \"sgn-BE-FR\":    \"sfb\",       \"sgn-BE-NL\":   \"vgt\",  \"sgn-CH-DE\":  \"sgg\",\n            \"zh-guoyu\":     \"cmn\",       \"zh-hakka\":     \"hak\",       \"zh-min-nan\":  \"nan\",  \"zh-xiang\":   \"hsn\",\n            \"sgn-BR\":       \"bzs\",       \"sgn-CO\":       \"csn\",       \"sgn-DE\":      \"gsg\",  \"sgn-DK\":     \"dsl\",\n            \"sgn-ES\":       \"ssp\",       \"sgn-FR\":       \"fsl\",       \"sgn-GB\":      \"bfi\",  \"sgn-GR\":     \"gss\",\n            \"sgn-IE\":       \"isg\",       \"sgn-IT\":       \"ise\",       \"sgn-JP\":      \"jsl\",  \"sgn-MX\":     \"mfs\",\n            \"sgn-NI\":       \"ncs\",       \"sgn-NL\":       \"dse\",       \"sgn-NO\":      \"nsl\",  \"sgn-PT\":     \"psr\",\n            \"sgn-SE\":       \"swl\",       \"sgn-US\":       \"ase\",       \"sgn-ZA\":      \"sfs\",  \"zh-cmn\":     \"cmn\",\n            \"zh-cmn-Hans\":  \"cmn-Hans\",  \"zh-cmn-Hant\":  \"cmn-Hant\",  \"zh-gan\":      \"gan\",  \"zh-wuu\":     \"wuu\",\n            \"zh-yue\":       \"yue\"\n        },\n        subtags: {\n              BU: \"MM\",   DD: \"DE\",   FX: \"FR\",   TP: \"TL\",   YD: \"YE\",   ZR: \"CD\",  heploc: \"alalc97\",\n            'in': \"id\",   iw: \"he\",   ji:  \"yi\",  jw: \"jv\",   mo: \"ro\",  ayx: \"nun\", bjd: \"drl\",\n             ccq: \"rki\", cjr: \"mom\", cka: \"cmr\", cmk: \"xch\", drh: \"khk\", drw: \"prs\", gav: \"dev\",\n             hrr: \"jal\", ibi: \"opa\", kgh: \"kml\", lcq: \"ppr\", mst: \"mry\", myt: \"mry\", sca: \"hle\",\n             tie: \"ras\", tkk: \"twm\", tlw: \"weo\", tnf: \"prs\", ybd: \"rki\", yma: \"lrr\"\n        },\n        extLang: {\n            aao: [ \"aao\", \"ar\"  ], abh: [ \"abh\", \"ar\"  ], abv: [ \"abv\", \"ar\"  ], acm: [ \"acm\", \"ar\"  ],\n            acq: [ \"acq\", \"ar\"  ], acw: [ \"acw\", \"ar\"  ], acx: [ \"acx\", \"ar\"  ], acy: [ \"acy\", \"ar\"  ],\n            adf: [ \"adf\", \"ar\"  ], ads: [ \"ads\", \"sgn\" ], aeb: [ \"aeb\", \"ar\"  ], aec: [ \"aec\", \"ar\"  ],\n            aed: [ \"aed\", \"sgn\" ], aen: [ \"aen\", \"sgn\" ], afb: [ \"afb\", \"ar\"  ], afg: [ \"afg\", \"sgn\" ],\n            ajp: [ \"ajp\", \"ar\"  ], apc: [ \"apc\", \"ar\"  ], apd: [ \"apd\", \"ar\"  ], arb: [ \"arb\", \"ar\"  ],\n            arq: [ \"arq\", \"ar\"  ], ars: [ \"ars\", \"ar\"  ], ary: [ \"ary\", \"ar\"  ], arz: [ \"arz\", \"ar\"  ],\n            ase: [ \"ase\", \"sgn\" ], asf: [ \"asf\", \"sgn\" ], asp: [ \"asp\", \"sgn\" ], asq: [ \"asq\", \"sgn\" ],\n            asw: [ \"asw\", \"sgn\" ], auz: [ \"auz\", \"ar\"  ], avl: [ \"avl\", \"ar\"  ], ayh: [ \"ayh\", \"ar\"  ],\n            ayl: [ \"ayl\", \"ar\"  ], ayn: [ \"ayn\", \"ar\"  ], ayp: [ \"ayp\", \"ar\"  ], bbz: [ \"bbz\", \"ar\"  ],\n            bfi: [ \"bfi\", \"sgn\" ], bfk: [ \"bfk\", \"sgn\" ], bjn: [ \"bjn\", \"ms\"  ], bog: [ \"bog\", \"sgn\" ],\n            bqn: [ \"bqn\", \"sgn\" ], bqy: [ \"bqy\", \"sgn\" ], btj: [ \"btj\", \"ms\"  ], bve: [ \"bve\", \"ms\"  ],\n            bvl: [ \"bvl\", \"sgn\" ], bvu: [ \"bvu\", \"ms\"  ], bzs: [ \"bzs\", \"sgn\" ], cdo: [ \"cdo\", \"zh\"  ],\n            cds: [ \"cds\", \"sgn\" ], cjy: [ \"cjy\", \"zh\"  ], cmn: [ \"cmn\", \"zh\"  ], coa: [ \"coa\", \"ms\"  ],\n            cpx: [ \"cpx\", \"zh\"  ], csc: [ \"csc\", \"sgn\" ], csd: [ \"csd\", \"sgn\" ], cse: [ \"cse\", \"sgn\" ],\n            csf: [ \"csf\", \"sgn\" ], csg: [ \"csg\", \"sgn\" ], csl: [ \"csl\", \"sgn\" ], csn: [ \"csn\", \"sgn\" ],\n            csq: [ \"csq\", \"sgn\" ], csr: [ \"csr\", \"sgn\" ], czh: [ \"czh\", \"zh\"  ], czo: [ \"czo\", \"zh\"  ],\n            doq: [ \"doq\", \"sgn\" ], dse: [ \"dse\", \"sgn\" ], dsl: [ \"dsl\", \"sgn\" ], dup: [ \"dup\", \"ms\"  ],\n            ecs: [ \"ecs\", \"sgn\" ], esl: [ \"esl\", \"sgn\" ], esn: [ \"esn\", \"sgn\" ], eso: [ \"eso\", \"sgn\" ],\n            eth: [ \"eth\", \"sgn\" ], fcs: [ \"fcs\", \"sgn\" ], fse: [ \"fse\", \"sgn\" ], fsl: [ \"fsl\", \"sgn\" ],\n            fss: [ \"fss\", \"sgn\" ], gan: [ \"gan\", \"zh\"  ], gds: [ \"gds\", \"sgn\" ], gom: [ \"gom\", \"kok\" ],\n            gse: [ \"gse\", \"sgn\" ], gsg: [ \"gsg\", \"sgn\" ], gsm: [ \"gsm\", \"sgn\" ], gss: [ \"gss\", \"sgn\" ],\n            gus: [ \"gus\", \"sgn\" ], hab: [ \"hab\", \"sgn\" ], haf: [ \"haf\", \"sgn\" ], hak: [ \"hak\", \"zh\"  ],\n            hds: [ \"hds\", \"sgn\" ], hji: [ \"hji\", \"ms\"  ], hks: [ \"hks\", \"sgn\" ], hos: [ \"hos\", \"sgn\" ],\n            hps: [ \"hps\", \"sgn\" ], hsh: [ \"hsh\", \"sgn\" ], hsl: [ \"hsl\", \"sgn\" ], hsn: [ \"hsn\", \"zh\"  ],\n            icl: [ \"icl\", \"sgn\" ], ils: [ \"ils\", \"sgn\" ], inl: [ \"inl\", \"sgn\" ], ins: [ \"ins\", \"sgn\" ],\n            ise: [ \"ise\", \"sgn\" ], isg: [ \"isg\", \"sgn\" ], isr: [ \"isr\", \"sgn\" ], jak: [ \"jak\", \"ms\"  ],\n            jax: [ \"jax\", \"ms\"  ], jcs: [ \"jcs\", \"sgn\" ], jhs: [ \"jhs\", \"sgn\" ], jls: [ \"jls\", \"sgn\" ],\n            jos: [ \"jos\", \"sgn\" ], jsl: [ \"jsl\", \"sgn\" ], jus: [ \"jus\", \"sgn\" ], kgi: [ \"kgi\", \"sgn\" ],\n            knn: [ \"knn\", \"kok\" ], kvb: [ \"kvb\", \"ms\"  ], kvk: [ \"kvk\", \"sgn\" ], kvr: [ \"kvr\", \"ms\"  ],\n            kxd: [ \"kxd\", \"ms\"  ], lbs: [ \"lbs\", \"sgn\" ], lce: [ \"lce\", \"ms\"  ], lcf: [ \"lcf\", \"ms\"  ],\n            liw: [ \"liw\", \"ms\"  ], lls: [ \"lls\", \"sgn\" ], lsg: [ \"lsg\", \"sgn\" ], lsl: [ \"lsl\", \"sgn\" ],\n            lso: [ \"lso\", \"sgn\" ], lsp: [ \"lsp\", \"sgn\" ], lst: [ \"lst\", \"sgn\" ], lsy: [ \"lsy\", \"sgn\" ],\n            ltg: [ \"ltg\", \"lv\"  ], lvs: [ \"lvs\", \"lv\"  ], lzh: [ \"lzh\", \"zh\"  ], max: [ \"max\", \"ms\"  ],\n            mdl: [ \"mdl\", \"sgn\" ], meo: [ \"meo\", \"ms\"  ], mfa: [ \"mfa\", \"ms\"  ], mfb: [ \"mfb\", \"ms\"  ],\n            mfs: [ \"mfs\", \"sgn\" ], min: [ \"min\", \"ms\"  ], mnp: [ \"mnp\", \"zh\"  ], mqg: [ \"mqg\", \"ms\"  ],\n            mre: [ \"mre\", \"sgn\" ], msd: [ \"msd\", \"sgn\" ], msi: [ \"msi\", \"ms\"  ], msr: [ \"msr\", \"sgn\" ],\n            mui: [ \"mui\", \"ms\"  ], mzc: [ \"mzc\", \"sgn\" ], mzg: [ \"mzg\", \"sgn\" ], mzy: [ \"mzy\", \"sgn\" ],\n            nan: [ \"nan\", \"zh\"  ], nbs: [ \"nbs\", \"sgn\" ], ncs: [ \"ncs\", \"sgn\" ], nsi: [ \"nsi\", \"sgn\" ],\n            nsl: [ \"nsl\", \"sgn\" ], nsp: [ \"nsp\", \"sgn\" ], nsr: [ \"nsr\", \"sgn\" ], nzs: [ \"nzs\", \"sgn\" ],\n            okl: [ \"okl\", \"sgn\" ], orn: [ \"orn\", \"ms\"  ], ors: [ \"ors\", \"ms\"  ], pel: [ \"pel\", \"ms\"  ],\n            pga: [ \"pga\", \"ar\"  ], pks: [ \"pks\", \"sgn\" ], prl: [ \"prl\", \"sgn\" ], prz: [ \"prz\", \"sgn\" ],\n            psc: [ \"psc\", \"sgn\" ], psd: [ \"psd\", \"sgn\" ], pse: [ \"pse\", \"ms\"  ], psg: [ \"psg\", \"sgn\" ],\n            psl: [ \"psl\", \"sgn\" ], pso: [ \"pso\", \"sgn\" ], psp: [ \"psp\", \"sgn\" ], psr: [ \"psr\", \"sgn\" ],\n            pys: [ \"pys\", \"sgn\" ], rms: [ \"rms\", \"sgn\" ], rsi: [ \"rsi\", \"sgn\" ], rsl: [ \"rsl\", \"sgn\" ],\n            sdl: [ \"sdl\", \"sgn\" ], sfb: [ \"sfb\", \"sgn\" ], sfs: [ \"sfs\", \"sgn\" ], sgg: [ \"sgg\", \"sgn\" ],\n            sgx: [ \"sgx\", \"sgn\" ], shu: [ \"shu\", \"ar\"  ], slf: [ \"slf\", \"sgn\" ], sls: [ \"sls\", \"sgn\" ],\n            sqk: [ \"sqk\", \"sgn\" ], sqs: [ \"sqs\", \"sgn\" ], ssh: [ \"ssh\", \"ar\"  ], ssp: [ \"ssp\", \"sgn\" ],\n            ssr: [ \"ssr\", \"sgn\" ], svk: [ \"svk\", \"sgn\" ], swc: [ \"swc\", \"sw\"  ], swh: [ \"swh\", \"sw\"  ],\n            swl: [ \"swl\", \"sgn\" ], syy: [ \"syy\", \"sgn\" ], tmw: [ \"tmw\", \"ms\"  ], tse: [ \"tse\", \"sgn\" ],\n            tsm: [ \"tsm\", \"sgn\" ], tsq: [ \"tsq\", \"sgn\" ], tss: [ \"tss\", \"sgn\" ], tsy: [ \"tsy\", \"sgn\" ],\n            tza: [ \"tza\", \"sgn\" ], ugn: [ \"ugn\", \"sgn\" ], ugy: [ \"ugy\", \"sgn\" ], ukl: [ \"ukl\", \"sgn\" ],\n            uks: [ \"uks\", \"sgn\" ], urk: [ \"urk\", \"ms\"  ], uzn: [ \"uzn\", \"uz\"  ], uzs: [ \"uzs\", \"uz\"  ],\n            vgt: [ \"vgt\", \"sgn\" ], vkk: [ \"vkk\", \"ms\"  ], vkt: [ \"vkt\", \"ms\"  ], vsi: [ \"vsi\", \"sgn\" ],\n            vsl: [ \"vsl\", \"sgn\" ], vsv: [ \"vsv\", \"sgn\" ], wuu: [ \"wuu\", \"zh\"  ], xki: [ \"xki\", \"sgn\" ],\n            xml: [ \"xml\", \"sgn\" ], xmm: [ \"xmm\", \"ms\"  ], xms: [ \"xms\", \"sgn\" ], yds: [ \"yds\", \"sgn\" ],\n            ysl: [ \"ysl\", \"sgn\" ], yue: [ \"yue\", \"zh\"  ], zib: [ \"zib\", \"sgn\" ], zlm: [ \"zlm\", \"ms\"  ],\n            zmi: [ \"zmi\", \"ms\"  ], zsl: [ \"zsl\", \"sgn\" ], zsm: [ \"zsm\", \"ms\"  ]\n        }\n    },\n\n    // Currency minor units output from get-4217 grunt task, formatted\n    currencyMinorUnits = {\n        BHD: 3, BYR: 0, XOF: 0, BIF: 0, XAF: 0, CLF: 4, CLP: 0, KMF: 0, DJF: 0,\n        XPF: 0, GNF: 0, ISK: 0, IQD: 3, JPY: 0, JOD: 3, KRW: 0, KWD: 3, LYD: 3,\n        OMR: 3, PYG: 0, RWF: 0, TND: 3, UGX: 0, UYI: 0, VUV: 0, VND: 0\n    };\n\n// Sect 6.2 Language Tags\n// ======================\n\n/**\n * The IsStructurallyValidLanguageTag abstract operation verifies that the locale\n * argument (which must be a String value)\n *\n * - represents a well-formed BCP 47 language tag as specified in RFC 5646 section\n *   2.1, or successor,\n * - does not include duplicate variant subtags, and\n * - does not include duplicate singleton subtags.\n *\n * The abstract operation returns true if locale can be generated from the ABNF\n * grammar in section 2.1 of the RFC, starting with Language-Tag, and does not\n * contain duplicate variant or singleton subtags (other than as a private use\n * subtag). It returns false otherwise. Terminal value characters in the grammar are\n * interpreted as the Unicode equivalents of the ASCII octet values given.\n */\nfunction /* 6.2.2 */IsStructurallyValidLanguageTag(locale) {\n    // represents a well-formed BCP 47 language tag as specified in RFC 5646\n    if (!expBCP47Syntax.test(locale))\n        return false;\n\n    // does not include duplicate variant subtags, and\n    if (expVariantDupes.test(locale))\n        return false;\n\n    // does not include duplicate singleton subtags.\n    if (expSingletonDupes.test(locale))\n        return false;\n\n    return true;\n}\n\n/**\n * The CanonicalizeLanguageTag abstract operation returns the canonical and case-\n * regularized form of the locale argument (which must be a String value that is\n * a structurally valid BCP 47 language tag as verified by the\n * IsStructurallyValidLanguageTag abstract operation). It takes the steps\n * specified in RFC 5646 section 4.5, or successor, to bring the language tag\n * into canonical form, and to regularize the case of the subtags, but does not\n * take the steps to bring a language tag into extlang form and to reorder\n * variant subtags.\n\n * The specifications for extensions to BCP 47 language tags, such as RFC 6067,\n * may include canonicalization rules for the extension subtag sequences they\n * define that go beyond the canonicalization rules of RFC 5646 section 4.5.\n * Implementations are allowed, but not required, to apply these additional rules.\n */\nfunction /* 6.2.3 */CanonicalizeLanguageTag (locale) {\n    var match, parts;\n\n    // A language tag is in 'canonical form' when the tag is well-formed\n    // according to the rules in Sections 2.1 and 2.2\n\n    // Section 2.1 says all subtags use lowercase...\n    locale = locale.toLowerCase();\n\n    // ...with 2 exceptions: 'two-letter and four-letter subtags that neither\n    // appear at the start of the tag nor occur after singletons.  Such two-letter\n    // subtags are all uppercase (as in the tags \"en-CA-x-ca\" or \"sgn-BE-FR\") and\n    // four-letter subtags are titlecase (as in the tag \"az-Latn-x-latn\").\n    parts = locale.split('-');\n    for (var i = 1, max = parts.length; i < max; i++) {\n        // Two-letter subtags are all uppercase\n        if (parts[i].length === 2)\n            parts[i] = parts[i].toUpperCase();\n\n        // Four-letter subtags are titlecase\n        else if (parts[i].length === 4)\n            parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].slice(1);\n\n        // Is it a singleton?\n        else if (parts[i].length === 1 && parts[i] !== 'x')\n            break;\n    }\n    locale = arrJoin.call(parts, '-');\n\n    // The steps laid out in RFC 5646 section 4.5 are as follows:\n\n    // 1.  Extension sequences are ordered into case-insensitive ASCII order\n    //     by singleton subtag.\n    if ((match = locale.match(expExtSequences)) && match.length > 1) {\n        // The built-in sort() sorts by ASCII order, so use that\n        match.sort();\n\n        // Replace all extensions with the joined, sorted array\n        locale = locale.replace(\n            RegExp('(?:' + expExtSequences.source + ')+', 'i'),\n            arrJoin.call(match, '')\n        );\n    }\n\n    // 2.  Redundant or grandfathered tags are replaced by their 'Preferred-\n    //     Value', if there is one.\n    if (hop.call(redundantTags.tags, locale))\n        locale = redundantTags.tags[locale];\n\n    // 3.  Subtags are replaced by their 'Preferred-Value', if there is one.\n    //     For extlangs, the original primary language subtag is also\n    //     replaced if there is a primary language subtag in the 'Preferred-\n    //     Value'.\n    parts = locale.split('-');\n\n    for (var i = 1, max = parts.length; i < max; i++) {\n        if (hop.call(redundantTags.subtags, parts[i]))\n            parts[i] = redundantTags.subtags[parts[i]];\n\n        else if (hop.call(redundantTags.extLang, parts[i])) {\n            parts[i] = redundantTags.extLang[parts[i]][0];\n\n            // For extlang tags, the prefix needs to be removed if it is redundant\n            if (i === 1 && redundantTags.extLang[parts[1]][1] === parts[0]) {\n                parts = arrSlice.call(parts, i++);\n                max -= 1;\n            }\n        }\n    }\n\n    return arrJoin.call(parts, '-');\n}\n\n/**\n * The DefaultLocale abstract operation returns a String value representing the\n * structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the\n * host environments current locale.\n */\nfunction /* 6.2.4 */DefaultLocale () {\n    return defaultLocale;\n}\n\n// Sect 6.3 Currency Codes\n// =======================\n\n/**\n * The IsWellFormedCurrencyCode abstract operation verifies that the currency argument\n * (after conversion to a String value) represents a well-formed 3-letter ISO currency\n * code. The following steps are taken:\n */\nfunction /* 6.3.1 */IsWellFormedCurrencyCode(currency) {\n    var\n        // 1. Let `c` be ToString(currency)\n        c = String(currency),\n\n        // 2. Let `normalized` be the result of mapping c to upper case as described\n        //    in 6.1.\n        normalized = toLatinUpperCase(c);\n\n    // 3. If the string length of normalized is not 3, return false.\n    // 4. If normalized contains any character that is not in the range \"A\" to \"Z\"\n    //    (U+0041 to U+005A), return false.\n    if (expCurrencyCode.test(normalized) === false)\n        return false;\n\n    // 5. Return true\n    return true;\n}\n\n// Sect 9.2 Abstract Operations\n// ============================\nfunction /* 9.2.1 */CanonicalizeLocaleList (locales) {\n// The abstract operation CanonicalizeLocaleList takes the following steps:\n\n    // 1. If locales is undefined, then a. Return a new empty List\n    if (locales === undefined)\n        return new List();\n\n    var\n        // 2. Let seen be a new empty List.\n        seen = new List(),\n\n        // 3. If locales is a String value, then\n        //    a. Let locales be a new array created as if by the expression new\n        //    Array(locales) where Array is the standard built-in constructor with\n        //    that name and locales is the value of locales.\n        locales = typeof locales === 'string' ? [ locales ] : locales,\n\n        // 4. Let O be ToObject(locales).\n        O = toObject(locales),\n\n        // 5. Let lenValue be the result of calling the [[Get]] internal method of\n        //    O with the argument \"length\".\n        // 6. Let len be ToUint32(lenValue).\n        len = O.length,\n\n        // 7. Let k be 0.\n        k = 0;\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n        var\n            // a. Let Pk be ToString(k).\n            Pk = String(k),\n\n            // b. Let kPresent be the result of calling the [[HasProperty]] internal\n            //    method of O with argument Pk.\n            kPresent = Pk in O;\n\n        // c. If kPresent is true, then\n        if (kPresent) {\n            var\n                // i. Let kValue be the result of calling the [[Get]] internal\n                //     method of O with argument Pk.\n                kValue = O[Pk];\n\n            // ii. If the type of kValue is not String or Object, then throw a\n            //     TypeError exception.\n            if (kValue == null || (typeof kValue !== 'string' && typeof kValue !== 'object'))\n                throw new TypeError('String or Object type expected');\n\n            var\n                // iii. Let tag be ToString(kValue).\n                tag = String(kValue);\n\n            // iv. If the result of calling the abstract operation\n            //     IsStructurallyValidLanguageTag (defined in 6.2.2), passing tag as\n            //     the argument, is false, then throw a RangeError exception.\n            if (!IsStructurallyValidLanguageTag(tag))\n                throw new RangeError(\"'\" + tag + \"' is not a structurally valid language tag\");\n\n            // v. Let tag be the result of calling the abstract operation\n            //    CanonicalizeLanguageTag (defined in 6.2.3), passing tag as the\n            //    argument.\n            tag = CanonicalizeLanguageTag(tag);\n\n            // vi. If tag is not an element of seen, then append tag as the last\n            //     element of seen.\n            if (arrIndexOf.call(seen, tag) === -1)\n                arrPush.call(seen, tag);\n        }\n\n        // d. Increase k by 1.\n        k++;\n    }\n\n    // 9. Return seen.\n    return seen;\n}\n\n/**\n * The BestAvailableLocale abstract operation compares the provided argument\n * locale, which must be a String value with a structurally valid and\n * canonicalized BCP 47 language tag, against the locales in availableLocales and\n * returns either the longest non-empty prefix of locale that is an element of\n * availableLocales, or undefined if there is no such element. It uses the\n * fallback mechanism of RFC 4647, section 3.4. The following steps are taken:\n */\nfunction /* 9.2.2 */BestAvailableLocale (availableLocales, locale) {\n    var\n       // 1. Let candidate be locale\n       candidate = locale;\n\n    // 2. Repeat\n    while (true) {\n        // a. If availableLocales contains an element equal to candidate, then return\n        // candidate.\n        if (arrIndexOf.call(availableLocales, candidate) > -1)\n            return candidate;\n\n        var\n            // b. Let pos be the character index of the last occurrence of \"-\"\n            // (U+002D) within candidate. If that character does not occur, return\n            // undefined.\n            pos = candidate.lastIndexOf('-');\n\n        if (pos < 0)\n            return;\n\n        // c. If pos  2 and the character \"-\" occurs at index pos-2 of candidate,\n        //    then decrease pos by 2.\n        if (pos >= 2 && candidate.charAt(pos - 2) === '-')\n            pos -= 2;\n\n        // d. Let candidate be the substring of candidate from position 0, inclusive,\n        //    to position pos, exclusive.\n        candidate = candidate.substring(0, pos);\n    }\n}\n\n/**\n * The LookupMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The following steps are taken:\n */\nfunction /* 9.2.3 */LookupMatcher (availableLocales, requestedLocales) {\n    var\n        // 1. Let i be 0.\n        i = 0,\n\n        // 2. Let len be the number of elements in requestedLocales.\n        len = requestedLocales.length,\n\n        // 3. Let availableLocale be undefined.\n        availableLocale;\n\n    // 4. Repeat while i < len and availableLocale is undefined:\n    while (i < len && !availableLocale) {\n        var\n            // a. Let locale be the element of requestedLocales at 0-origined list\n            //    position i.\n            locale = requestedLocales[i],\n\n            // b. Let noExtensionsLocale be the String value that is locale with all\n            //    Unicode locale extension sequences removed.\n            noExtensionsLocale = String(locale).replace(expUnicodeExSeq, ''),\n\n            // c. Let availableLocale be the result of calling the\n            //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n            //    arguments availableLocales and noExtensionsLocale.\n            availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\n        // d. Increase i by 1.\n        i++;\n    }\n\n    var\n        // 5. Let result be a new Record.\n        result = new Record();\n\n    // 6. If availableLocale is not undefined, then\n    if (availableLocale !== undefined) {\n        // a. Set result.[[locale]] to availableLocale.\n        result['[[locale]]'] = availableLocale;\n\n        // b. If locale and noExtensionsLocale are not the same String value, then\n        if (String(locale) !== String(noExtensionsLocale)) {\n            var\n                // i. Let extension be the String value consisting of the first\n                //    substring of locale that is a Unicode locale extension sequence.\n                extension = locale.match(expUnicodeExSeq)[0],\n\n                // ii. Let extensionIndex be the character position of the initial\n                //     \"-\" of the first Unicode locale extension sequence within locale.\n                extensionIndex = locale.indexOf('-u-');\n\n            // iii. Set result.[[extension]] to extension.\n            result['[[extension]]'] = extension;\n\n            // iv. Set result.[[extensionIndex]] to extensionIndex.\n            result['[[extensionIndex]]'] = extensionIndex;\n        }\n    }\n    // 7. Else\n    else\n        // a. Set result.[[locale]] to the value returned by the DefaultLocale abstract\n        //    operation (defined in 6.2.4).\n        result['[[locale]]'] = DefaultLocale();\n\n    // 8. Return result\n    return result;\n}\n\n/**\n * The BestFitMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The algorithm is implementation dependent, but should produce results\n * that a typical user of the requested locales would perceive as at least as\n * good as those produced by the LookupMatcher abstract operation. Options\n * specified through Unicode locale extension sequences must be ignored by the\n * algorithm. Information about such subsequences is returned separately.\n * The abstract operation returns a record with a [[locale]] field, whose value\n * is the language tag of the selected locale, which must be an element of\n * availableLocales. If the language tag of the request locale that led to the\n * selected locale contained a Unicode locale extension sequence, then the\n * returned record also contains an [[extension]] field whose value is the first\n * Unicode locale extension sequence, and an [[extensionIndex]] field whose value\n * is the index of the first Unicode locale extension sequence within the request\n * locale language tag.\n */\nfunction /* 9.2.4 */BestFitMatcher (availableLocales, requestedLocales) {\n    return LookupMatcher(availableLocales, requestedLocales);\n}\n\n/**\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\n * requestedLocales against the locales in availableLocales and determines the\n * best available language to meet the request. availableLocales and\n * requestedLocales must be provided as List values, options as a Record.\n */\nfunction /* 9.2.5 */ResolveLocale (availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {\n    if (availableLocales.length === 0) {\n        throw new ReferenceError('No locale data has been provided for this object yet.');\n    }\n\n    // The following steps are taken:\n    var\n        // 1. Let matcher be the value of options.[[localeMatcher]].\n        matcher = options['[[localeMatcher]]'];\n\n    // 2. If matcher is \"lookup\", then\n    if (matcher === 'lookup')\n        var\n            // a. Let r be the result of calling the LookupMatcher abstract operation\n            //    (defined in 9.2.3) with arguments availableLocales and\n            //    requestedLocales.\n            r = LookupMatcher(availableLocales, requestedLocales);\n\n    // 3. Else\n    else\n        var\n            // a. Let r be the result of calling the BestFitMatcher abstract\n            //    operation (defined in 9.2.4) with arguments availableLocales and\n            //    requestedLocales.\n            r = BestFitMatcher(availableLocales, requestedLocales);\n\n    var\n        // 4. Let foundLocale be the value of r.[[locale]].\n        foundLocale = r['[[locale]]'];\n\n    // 5. If r has an [[extension]] field, then\n    if (hop.call(r, '[[extension]]'))\n        var\n            // a. Let extension be the value of r.[[extension]].\n            extension = r['[[extension]]'],\n            // b. Let extensionIndex be the value of r.[[extensionIndex]].\n            extensionIndex = r['[[extensionIndex]]'],\n            // c. Let split be the standard built-in function object defined in ES5,\n            //    15.5.4.14.\n            split = String.prototype.split,\n            // d. Let extensionSubtags be the result of calling the [[Call]] internal\n            //    method of split with extension as the this value and an argument\n            //    list containing the single item \"-\".\n            extensionSubtags = split.call(extension, '-'),\n            // e. Let extensionSubtagsLength be the result of calling the [[Get]]\n            //    internal method of extensionSubtags with argument \"length\".\n            extensionSubtagsLength = extensionSubtags.length;\n\n    var\n        // 6. Let result be a new Record.\n        result = new Record();\n\n    // 7. Set result.[[dataLocale]] to foundLocale.\n    result['[[dataLocale]]'] = foundLocale;\n\n    var\n        // 8. Let supportedExtension be \"-u\".\n        supportedExtension = '-u',\n        // 9. Let i be 0.\n        i = 0,\n        // 10. Let len be the result of calling the [[Get]] internal method of\n        //     relevantExtensionKeys with argument \"length\".\n        len = relevantExtensionKeys.length;\n\n    // 11 Repeat while i < len:\n    while (i < len) {\n        var\n            // a. Let key be the result of calling the [[Get]] internal method of\n            //    relevantExtensionKeys with argument ToString(i).\n            key = relevantExtensionKeys[i],\n            // b. Let foundLocaleData be the result of calling the [[Get]] internal\n            //    method of localeData with the argument foundLocale.\n            foundLocaleData = localeData[foundLocale],\n            // c. Let keyLocaleData be the result of calling the [[Get]] internal\n            //    method of foundLocaleData with the argument key.\n            keyLocaleData = foundLocaleData[key],\n            // d. Let value be the result of calling the [[Get]] internal method of\n            //    keyLocaleData with argument \"0\".\n            value = keyLocaleData['0'],\n            // e. Let supportedExtensionAddition be \"\".\n            supportedExtensionAddition = '',\n            // f. Let indexOf be the standard built-in function object defined in\n            //    ES5, 15.4.4.14.\n            indexOf = arrIndexOf;\n\n        // g. If extensionSubtags is not undefined, then\n        if (extensionSubtags !== undefined) {\n            var\n                // i. Let keyPos be the result of calling the [[Call]] internal\n                //    method of indexOf with extensionSubtags as the this value and\n                // an argument list containing the single item key.\n                keyPos = indexOf.call(extensionSubtags, key);\n\n            // ii. If keyPos  -1, then\n            if (keyPos !== -1) {\n                // 1. If keyPos + 1 < extensionSubtagsLength and the length of the\n                //    result of calling the [[Get]] internal method of\n                //    extensionSubtags with argument ToString(keyPos +1) is greater\n                //    than 2, then\n                if (keyPos + 1 < extensionSubtagsLength\n                        && extensionSubtags[keyPos + 1].length > 2) {\n                    var\n                        // a. Let requestedValue be the result of calling the [[Get]]\n                        //    internal method of extensionSubtags with argument\n                        //    ToString(keyPos + 1).\n                        requestedValue = extensionSubtags[keyPos + 1],\n                        // b. Let valuePos be the result of calling the [[Call]]\n                        //    internal method of indexOf with keyLocaleData as the\n                        //    this value and an argument list containing the single\n                        //    item requestedValue.\n                        valuePos = indexOf.call(keyLocaleData, requestedValue);\n\n                    // c. If valuePos  -1, then\n                    if (valuePos !== -1)\n                        var\n                            // i. Let value be requestedValue.\n                            value = requestedValue,\n                            // ii. Let supportedExtensionAddition be the\n                            //     concatenation of \"-\", key, \"-\", and value.\n                            supportedExtensionAddition = '-' + key + '-' + value;\n                }\n                // 2. Else\n                else {\n                    var\n                        // a. Let valuePos be the result of calling the [[Call]]\n                        // internal method of indexOf with keyLocaleData as the this\n                        // value and an argument list containing the single item\n                        // \"true\".\n                        valuePos = indexOf(keyLocaleData, 'true');\n\n                    // b. If valuePos  -1, then\n                    if (valuePos !== -1)\n                        var\n                            // i. Let value be \"true\".\n                            value = 'true';\n                }\n            }\n        }\n        // h. If options has a field [[<key>]], then\n        if (hop.call(options, '[[' + key + ']]')) {\n            var\n                // i. Let optionsValue be the value of options.[[<key>]].\n                optionsValue = options['[[' + key + ']]'];\n\n            // ii. If the result of calling the [[Call]] internal method of indexOf\n            //     with keyLocaleData as the this value and an argument list\n            //     containing the single item optionsValue is not -1, then\n            if (indexOf.call(keyLocaleData, optionsValue) !== -1) {\n                // 1. If optionsValue is not equal to value, then\n                if (optionsValue !== value) {\n                    // a. Let value be optionsValue.\n                    value = optionsValue;\n                    // b. Let supportedExtensionAddition be \"\".\n                    supportedExtensionAddition = '';\n                }\n            }\n        }\n        // i. Set result.[[<key>]] to value.\n        result['[[' + key + ']]'] = value;\n\n        // j. Append supportedExtensionAddition to supportedExtension.\n        supportedExtension += supportedExtensionAddition;\n\n        // k. Increase i by 1.\n        i++;\n    }\n    // 12. If the length of supportedExtension is greater than 2, then\n    if (supportedExtension.length > 2) {\n        var\n            // a. Let preExtension be the substring of foundLocale from position 0,\n            //    inclusive, to position extensionIndex, exclusive.\n            preExtension = foundLocale.substring(0, extensionIndex),\n            // b. Let postExtension be the substring of foundLocale from position\n            //    extensionIndex to the end of the string.\n            postExtension = foundLocale.substring(extensionIndex),\n            // c. Let foundLocale be the concatenation of preExtension,\n            //    supportedExtension, and postExtension.\n            foundLocale = preExtension + supportedExtension + postExtension;\n    }\n    // 13. Set result.[[locale]] to foundLocale.\n    result['[[locale]]'] = foundLocale;\n\n    // 14. Return result.\n    return result;\n}\n\n/**\n * The LookupSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n * The following steps are taken:\n */\nfunction /* 9.2.6 */LookupSupportedLocales (availableLocales, requestedLocales) {\n    var\n        // 1. Let len be the number of elements in requestedLocales.\n        len = requestedLocales.length,\n        // 2. Let subset be a new empty List.\n        subset = new List(),\n        // 3. Let k be 0.\n        k = 0;\n\n    // 4. Repeat while k < len\n    while (k < len) {\n        var\n            // a. Let locale be the element of requestedLocales at 0-origined list\n            //    position k.\n            locale = requestedLocales[k],\n            // b. Let noExtensionsLocale be the String value that is locale with all\n            //    Unicode locale extension sequences removed.\n            noExtensionsLocale = String(locale).replace(expUnicodeExSeq, ''),\n            // c. Let availableLocale be the result of calling the\n            //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n            //    arguments availableLocales and noExtensionsLocale.\n            availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\n        // d. If availableLocale is not undefined, then append locale to the end of\n        //    subset.\n        if (availableLocale !== undefined)\n            arrPush.call(subset, locale);\n\n        // e. Increment k by 1.\n        k++;\n    }\n\n    var\n        // 5. Let subsetArray be a new Array object whose elements are the same\n        //    values in the same order as the elements of subset.\n        subsetArray = arrSlice.call(subset);\n\n    // 6. Return subsetArray.\n    return subsetArray;\n}\n\n/**\n * The BestFitSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the Best Fit Matcher\n * algorithm. Locales appear in the same order in the returned list as in\n * requestedLocales. The steps taken are implementation dependent.\n */\nfunction /*9.2.7 */BestFitSupportedLocales (availableLocales, requestedLocales) {\n    // ###TODO: implement this function as described by the specification###\n    return LookupSupportedLocales(availableLocales, requestedLocales);\n}\n\n/**\n * The SupportedLocales abstract operation returns the subset of the provided BCP\n * 47 language priority list requestedLocales for which availableLocales has a\n * matching locale. Two algorithms are available to match the locales: the Lookup\n * algorithm described in RFC 4647 section 3.4, and an implementation dependent\n * best-fit algorithm. Locales appear in the same order in the returned list as\n * in requestedLocales. The following steps are taken:\n */\nfunction /*9.2.8 */SupportedLocales (availableLocales, requestedLocales, options) {\n    // 1. If options is not undefined, then\n    if (options !== undefined) {\n        var\n            // a. Let options be ToObject(options).\n            options = new Record(toObject(options)),\n            // b. Let matcher be the result of calling the [[Get]] internal method of\n            //    options with argument \"localeMatcher\".\n            matcher = options.localeMatcher;\n\n        // c. If matcher is not undefined, then\n        if (matcher !== undefined) {\n            // i. Let matcher be ToString(matcher).\n            matcher = String(matcher);\n\n            // ii. If matcher is not \"lookup\" or \"best fit\", then throw a RangeError\n            //     exception.\n            if (matcher !== 'lookup' && matcher !== 'best fit')\n                throw new RangeError('matcher should be \"lookup\" or \"best fit\"');\n        }\n    }\n    // 2. If matcher is undefined or \"best fit\", then\n    if (matcher === undefined || matcher === 'best fit')\n        var\n            // a. Let subset be the result of calling the BestFitSupportedLocales\n            //    abstract operation (defined in 9.2.7) with arguments\n            //    availableLocales and requestedLocales.\n            subset = BestFitSupportedLocales(availableLocales, requestedLocales);\n    // 3. Else\n    else\n        var\n            // a. Let subset be the result of calling the LookupSupportedLocales\n            //    abstract operation (defined in 9.2.6) with arguments\n            //    availableLocales and requestedLocales.\n            subset = LookupSupportedLocales(availableLocales, requestedLocales);\n\n    // 4. For each named own property name P of subset,\n    for (var P in subset) {\n        if (!hop.call(subset, P))\n            continue;\n\n        // a. Let desc be the result of calling the [[GetOwnProperty]] internal\n        //    method of subset with P.\n        // b. Set desc.[[Writable]] to false.\n        // c. Set desc.[[Configurable]] to false.\n        // d. Call the [[DefineOwnProperty]] internal method of subset with P, desc,\n        //    and true as arguments.\n        defineProperty(subset, P, {\n            writable: false, configurable: false, value: subset[P]\n        });\n    }\n    // \"Freeze\" the array so no new elements can be added\n    defineProperty(subset, 'length', { writable: false });\n\n    // 5. Return subset\n    return subset;\n}\n\n/**\n * The GetOption abstract operation extracts the value of the property named\n * property from the provided options object, converts it to the required type,\n * checks whether it is one of a List of allowed values, and fills in a fallback\n * value if necessary.\n */\nfunction /*9.2.9 */GetOption (options, property, type, values, fallback) {\n    var\n        // 1. Let value be the result of calling the [[Get]] internal method of\n        //    options with argument property.\n        value = options[property];\n\n    // 2. If value is not undefined, then\n    if (value !== undefined) {\n        // a. Assert: type is \"boolean\" or \"string\".\n        // b. If type is \"boolean\", then let value be ToBoolean(value).\n        // c. If type is \"string\", then let value be ToString(value).\n        value = type === 'boolean' ? Boolean(value)\n                  : (type === 'string' ? String(value) : value);\n\n        // d. If values is not undefined, then\n        if (values !== undefined) {\n            // i. If values does not contain an element equal to value, then throw a\n            //    RangeError exception.\n            if (arrIndexOf.call(values, value) === -1)\n                throw new RangeError(\"'\" + value + \"' is not an allowed value for `\" + property +'`');\n        }\n\n        // e. Return value.\n        return value;\n    }\n    // Else return fallback.\n    return fallback;\n}\n\n/**\n * The GetNumberOption abstract operation extracts a property value from the\n * provided options object, converts it to a Number value, checks whether it is\n * in the allowed range, and fills in a fallback value if necessary.\n */\nfunction /* 9.2.10 */GetNumberOption (options, property, minimum, maximum, fallback) {\n    var\n        // 1. Let value be the result of calling the [[Get]] internal method of\n        //    options with argument property.\n        value = options[property];\n\n    // 2. If value is not undefined, then\n    if (value !== undefined) {\n        // a. Let value be ToNumber(value).\n        value = Number(value);\n\n        // b. If value is NaN or less than minimum or greater than maximum, throw a\n        //    RangeError exception.\n        if (isNaN(value) || value < minimum || value > maximum)\n            throw new RangeError('Value is not a number or outside accepted range');\n\n        // c. Return floor(value).\n        return Math.floor(value);\n    }\n    // 3. Else return fallback.\n    return fallback;\n}\n\n// 11.1 The Intl.NumberFormat constructor\n// ======================================\n\n// Define the NumberFormat constructor internally so it cannot be tainted\nfunction NumberFormatConstructor () {\n    var locales = arguments[0];\n    var options = arguments[1];\n\n    if (!this || this === Intl) {\n        return new Intl.NumberFormat(locales, options);\n    }\n\n    return InitializeNumberFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'NumberFormat', {\n    configurable: true,\n    writable: true,\n    value: NumberFormatConstructor\n});\n\n// Must explicitly set prototypes as unwritable\ndefineProperty(Intl.NumberFormat, 'prototype', {\n    writable: false\n});\n\n/**\n * The abstract operation InitializeNumberFormat accepts the arguments\n * numberFormat (which must be an object), locales, and options. It initializes\n * numberFormat as a NumberFormat object.\n */\nfunction /*11.1.1.1 */InitializeNumberFormat (numberFormat, locales, options) {\n    var\n    // This will be a internal properties object if we're not already initialized\n        internal = getInternalProperties(numberFormat),\n\n    // Create an object whose props can be used to restore the values of RegExp props\n        regexpState = createRegExpRestore();\n\n    // 1. If numberFormat has an [[initializedIntlObject]] internal property with\n    // value true, throw a TypeError exception.\n    if (internal['[[initializedIntlObject]]'] === true)\n        throw new TypeError('`this` object has already been initialized as an Intl object');\n\n    // Need this to access the `internal` object\n    defineProperty(numberFormat, '__getInternalProperties', {\n        value: function () {\n            // NOTE: Non-standard, for internal use only\n            if (arguments[0] === secret)\n                return internal;\n        }\n    });\n\n    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n    internal['[[initializedIntlObject]]'] = true;\n\n    var\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n        requestedLocales = CanonicalizeLocaleList(locales);\n\n    // 4. If options is undefined, then\n    if (options === undefined)\n        // a. Let options be the result of creating a new object as if by the\n        // expression new Object() where Object is the standard built-in constructor\n        // with that name.\n        options = {};\n\n    // 5. Else\n    else\n        // a. Let options be ToObject(options).\n        options = toObject(options);\n\n    var\n    // 6. Let opt be a new Record.\n        opt = new Record(),\n\n    // 7. Let matcher be the result of calling the GetOption abstract operation\n    //    (defined in 9.2.9) with the arguments options, \"localeMatcher\", \"string\",\n    //    a List containing the two String values \"lookup\" and \"best fit\", and\n    //    \"best fit\".\n        matcher =  GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\n    // 8. Set opt.[[localeMatcher]] to matcher.\n    opt['[[localeMatcher]]'] = matcher;\n\n    var\n    // 9. Let NumberFormat be the standard built-in object that is the initial value\n    //    of Intl.NumberFormat.\n    // 10. Let localeData be the value of the [[localeData]] internal property of\n    //     NumberFormat.\n        localeData = internals.NumberFormat['[[localeData]]'],\n\n    // 11. Let r be the result of calling the ResolveLocale abstract operation\n    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n    //     NumberFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n    //     internal property of NumberFormat, and localeData.\n        r = ResolveLocale(\n                internals.NumberFormat['[[availableLocales]]'], requestedLocales,\n                opt, internals.NumberFormat['[[relevantExtensionKeys]]'], localeData\n            );\n\n    // 12. Set the [[locale]] internal property of numberFormat to the value of\n    //     r.[[locale]].\n    internal['[[locale]]'] = r['[[locale]]'];\n\n    // 13. Set the [[numberingSystem]] internal property of numberFormat to the value\n    //     of r.[[nu]].\n    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\n    // The specification doesn't tell us to do this, but it's helpful later on\n    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\n    var\n    // 14. Let dataLocale be the value of r.[[dataLocale]].\n        dataLocale = r['[[dataLocale]]'],\n\n    // 15. Let s be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"style\", \"string\", a List containing the three String\n    //     values \"decimal\", \"percent\", and \"currency\", and \"decimal\".\n        s = GetOption(options, 'style', 'string', new List('decimal', 'percent', 'currency'), 'decimal');\n\n    // 16. Set the [[style]] internal property of numberFormat to s.\n    internal['[[style]]'] = s;\n\n    var\n    // 17. Let c be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"currency\", \"string\", undefined, and undefined.\n        c = GetOption(options, 'currency', 'string');\n\n    // 18. If c is not undefined and the result of calling the\n    //     IsWellFormedCurrencyCode abstract operation (defined in 6.3.1) with\n    //     argument c is false, then throw a RangeError exception.\n    if (c !== undefined && !IsWellFormedCurrencyCode(c))\n        throw new RangeError(\"'\" + c + \"' is not a valid currency code\");\n\n    // 19. If s is \"currency\" and c is undefined, throw a TypeError exception.\n    if (s === 'currency' && c === undefined)\n        throw new TypeError('Currency code is required when style is currency');\n\n    // 20. If s is \"currency\", then\n    if (s === 'currency') {\n        // a. Let c be the result of converting c to upper case as specified in 6.1.\n        c = c.toUpperCase();\n\n        // b. Set the [[currency]] internal property of numberFormat to c.\n        internal['[[currency]]'] = c;\n\n        var\n        // c. Let cDigits be the result of calling the CurrencyDigits abstract\n        //    operation (defined below) with argument c.\n            cDigits = CurrencyDigits(c);\n    }\n\n    var\n    // 21. Let cd be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"currencyDisplay\", \"string\", a List containing the\n    //     three String values \"code\", \"symbol\", and \"name\", and \"symbol\".\n        cd = GetOption(options, 'currencyDisplay', 'string', new List('code', 'symbol', 'name'), 'symbol');\n\n    // 22. If s is \"currency\", then set the [[currencyDisplay]] internal property of\n    //     numberFormat to cd.\n    if (s === 'currency')\n        internal['[[currencyDisplay]]'] = cd;\n\n    var\n    // 23. Let mnid be the result of calling the GetNumberOption abstract operation\n    //     (defined in 9.2.10) with arguments options, \"minimumIntegerDigits\", 1, 21,\n    //     and 1.\n        mnid = GetNumberOption(options, 'minimumIntegerDigits', 1, 21, 1);\n\n    // 24. Set the [[minimumIntegerDigits]] internal property of numberFormat to mnid.\n    internal['[[minimumIntegerDigits]]'] = mnid;\n\n    var\n    // 25. If s is \"currency\", then let mnfdDefault be cDigits; else let mnfdDefault\n    //     be 0.\n        mnfdDefault = s === 'currency' ? cDigits : 0,\n\n    // 26. Let mnfd be the result of calling the GetNumberOption abstract operation\n    //     with arguments options, \"minimumFractionDigits\", 0, 20, and mnfdDefault.\n        mnfd = GetNumberOption(options, 'minimumFractionDigits', 0, 20, mnfdDefault);\n\n    // 27. Set the [[minimumFractionDigits]] internal property of numberFormat to mnfd.\n    internal['[[minimumFractionDigits]]'] = mnfd;\n\n    var\n    // 28. If s is \"currency\", then let mxfdDefault be max(mnfd, cDigits); else if s\n    //     is \"percent\", then let mxfdDefault be max(mnfd, 0); else let mxfdDefault\n    //     be max(mnfd, 3).\n        mxfdDefault = s === 'currency' ? Math.max(mnfd, cDigits)\n                    : (s === 'percent' ? Math.max(mnfd, 0) : Math.max(mnfd, 3)),\n\n    // 29. Let mxfd be the result of calling the GetNumberOption abstract operation\n    //     with arguments options, \"maximumFractionDigits\", mnfd, 20, and mxfdDefault.\n        mxfd = GetNumberOption(options, 'maximumFractionDigits', mnfd, 20, mxfdDefault);\n\n    // 30. Set the [[maximumFractionDigits]] internal property of numberFormat to mxfd.\n    internal['[[maximumFractionDigits]]'] = mxfd;\n\n    var\n    // 31. Let mnsd be the result of calling the [[Get]] internal method of options\n    //     with argument \"minimumSignificantDigits\".\n        mnsd = options.minimumSignificantDigits,\n\n    // 32. Let mxsd be the result of calling the [[Get]] internal method of options\n    //     with argument \"maximumSignificantDigits\".\n        mxsd = options.maximumSignificantDigits;\n\n    // 33. If mnsd is not undefined or mxsd is not undefined, then:\n    if (mnsd !== undefined || mxsd !== undefined) {\n        // a. Let mnsd be the result of calling the GetNumberOption abstract\n        //    operation with arguments options, \"minimumSignificantDigits\", 1, 21,\n        //    and 1.\n        mnsd = GetNumberOption(options, 'minimumSignificantDigits', 1, 21, 1);\n\n        // b. Let mxsd be the result of calling the GetNumberOption abstract\n        //     operation with arguments options, \"maximumSignificantDigits\", mnsd,\n        //     21, and 21.\n        mxsd = GetNumberOption(options, 'maximumSignificantDigits', mnsd, 21, 21);\n\n        // c. Set the [[minimumSignificantDigits]] internal property of numberFormat\n        //    to mnsd, and the [[maximumSignificantDigits]] internal property of\n        //    numberFormat to mxsd.\n        internal['[[minimumSignificantDigits]]'] = mnsd;\n        internal['[[maximumSignificantDigits]]'] = mxsd;\n    }\n    var\n    // 34. Let g be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"useGrouping\", \"boolean\", undefined, and true.\n        g = GetOption(options, 'useGrouping', 'boolean', undefined, true);\n\n    // 35. Set the [[useGrouping]] internal property of numberFormat to g.\n    internal['[[useGrouping]]'] = g;\n\n    var\n    // 36. Let dataLocaleData be the result of calling the [[Get]] internal method of\n    //     localeData with argument dataLocale.\n        dataLocaleData = localeData[dataLocale],\n\n    // 37. Let patterns be the result of calling the [[Get]] internal method of\n    //     dataLocaleData with argument \"patterns\".\n        patterns = dataLocaleData.patterns;\n\n    // 38. Assert: patterns is an object (see 11.2.3)\n\n    var\n    // 39. Let stylePatterns be the result of calling the [[Get]] internal method of\n    //     patterns with argument s.\n        stylePatterns = patterns[s];\n\n    // 40. Set the [[positivePattern]] internal property of numberFormat to the\n    //     result of calling the [[Get]] internal method of stylePatterns with the\n    //     argument \"positivePattern\".\n    internal['[[positivePattern]]'] = stylePatterns.positivePattern;\n\n    // 41. Set the [[negativePattern]] internal property of numberFormat to the\n    //     result of calling the [[Get]] internal method of stylePatterns with the\n    //     argument \"negativePattern\".\n    internal['[[negativePattern]]'] = stylePatterns.negativePattern;\n\n    // 42. Set the [[boundFormat]] internal property of numberFormat to undefined.\n    internal['[[boundFormat]]'] = undefined;\n\n    // 43. Set the [[initializedNumberFormat]] internal property of numberFormat to\n    //     true.\n    internal['[[initializedNumberFormat]]'] = true;\n\n    // In ES3, we need to pre-bind the format() function\n    if (es3)\n        numberFormat.format = GetFormatNumber.call(numberFormat);\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // Return the newly initialised object\n    return numberFormat;\n}\n\nfunction CurrencyDigits(currency) {\n    // When the CurrencyDigits abstract operation is called with an argument currency\n    // (which must be an upper case String value), the following steps are taken:\n\n    // 1. If the ISO 4217 currency and funds code list contains currency as an\n    // alphabetic code, then return the minor unit value corresponding to the\n    // currency from the list; else return 2.\n    return currencyMinorUnits[currency] !== undefined\n                ? currencyMinorUnits[currency]\n                : 2;\n}\n\n/* 11.2.3 */internals.NumberFormat = {\n    '[[availableLocales]]': [],\n    '[[relevantExtensionKeys]]': ['nu'],\n    '[[localeData]]': {}\n};\n\n/**\n * When the supportedLocalesOf method of Intl.NumberFormat is called, the\n * following steps are taken:\n */\n/* 11.2.2 */defineProperty(Intl.NumberFormat, 'supportedLocalesOf', {\n    configurable: true,\n    writable: true,\n    value: fnBind.call(supportedLocalesOf, internals.NumberFormat)\n});\n\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * NumberFormat object.\n */\n/* 11.3.2 */defineProperty(Intl.NumberFormat.prototype, 'format', {\n    configurable: true,\n    get: GetFormatNumber\n});\n\nfunction GetFormatNumber() {\n        var internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\n        // Satisfy test 11.3_b\n        if (!internal || !internal['[[initializedNumberFormat]]'])\n            throw new TypeError('`this` value for format() is not an initialized Intl.NumberFormat object.');\n\n        // The value of the [[Get]] attribute is a function that takes the following\n        // steps:\n\n        // 1. If the [[boundFormat]] internal property of this NumberFormat object\n        //    is undefined, then:\n        if (internal['[[boundFormat]]'] === undefined) {\n            var\n            // a. Let F be a Function object, with internal properties set as\n            //    specified for built-in functions in ES5, 15, or successor, and the\n            //    length property set to 1, that takes the argument value and\n            //    performs the following steps:\n                F = function (value) {\n                    // i. If value is not provided, then let value be undefined.\n                    // ii. Let x be ToNumber(value).\n                    // iii. Return the result of calling the FormatNumber abstract\n                    //      operation (defined below) with arguments this and x.\n                    return FormatNumber(this, /* x = */Number(value));\n                },\n\n            // b. Let bind be the standard built-in function object defined in ES5,\n            //    15.3.4.5.\n            // c. Let bf be the result of calling the [[Call]] internal method of\n            //    bind with F as the this value and an argument list containing\n            //    the single item this.\n                bf = fnBind.call(F, this);\n\n            // d. Set the [[boundFormat]] internal property of this NumberFormat\n            //    object to bf.\n            internal['[[boundFormat]]'] = bf;\n        }\n        // Return the value of the [[boundFormat]] internal property of this\n        // NumberFormat object.\n        return internal['[[boundFormat]]'];\n    }\n\n/**\n * When the FormatNumber abstract operation is called with arguments numberFormat\n * (which must be an object initialized as a NumberFormat) and x (which must be a\n * Number value), it returns a String value representing x according to the\n * effective locale and the formatting options of numberFormat.\n */\nfunction FormatNumber (numberFormat, x) {\n    var n,\n\n    // Create an object whose props can be used to restore the values of RegExp props\n        regexpState = createRegExpRestore(),\n\n        internal = getInternalProperties(numberFormat),\n        locale = internal['[[dataLocale]]'],\n        nums   = internal['[[numberingSystem]]'],\n        data   = internals.NumberFormat['[[localeData]]'][locale],\n        ild    = data.symbols[nums] || data.symbols.latn,\n\n    // 1. Let negative be false.\n        negative = false;\n\n    // 2. If the result of isFinite(x) is false, then\n    if (isFinite(x) === false) {\n        // a. If x is NaN, then let n be an ILD String value indicating the NaN value.\n        if (isNaN(x))\n            n = ild.nan;\n\n        // b. Else\n        else {\n            // a. Let n be an ILD String value indicating infinity.\n            n = ild.infinity;\n            // b. If x < 0, then let negative be true.\n            if (x < 0)\n                negative = true;\n        }\n    }\n    // 3. Else\n    else {\n        // a. If x < 0, then\n        if (x < 0) {\n            // i. Let negative be true.\n            negative = true;\n            // ii. Let x be -x.\n            x = -x;\n        }\n\n        // b. If the value of the [[style]] internal property of numberFormat is\n        //    \"percent\", let x be 100  x.\n        if (internal['[[style]]'] === 'percent')\n            x *= 100;\n\n        // c. If the [[minimumSignificantDigits]] and [[maximumSignificantDigits]]\n        //    internal properties of numberFormat are present, then\n        if (hop.call(internal, '[[minimumSignificantDigits]]') &&\n                hop.call(internal, '[[maximumSignificantDigits]]'))\n            // i. Let n be the result of calling the ToRawPrecision abstract operation\n            //    (defined below), passing as arguments x and the values of the\n            //    [[minimumSignificantDigits]] and [[maximumSignificantDigits]]\n            //    internal properties of numberFormat.\n            n = ToRawPrecision(x,\n                  internal['[[minimumSignificantDigits]]'],\n                  internal['[[maximumSignificantDigits]]']);\n        // d. Else\n        else\n            // i. Let n be the result of calling the ToRawFixed abstract operation\n            //    (defined below), passing as arguments x and the values of the\n            //    [[minimumIntegerDigits]], [[minimumFractionDigits]], and\n            //    [[maximumFractionDigits]] internal properties of numberFormat.\n            n = ToRawFixed(x,\n                  internal['[[minimumIntegerDigits]]'],\n                  internal['[[minimumFractionDigits]]'],\n                  internal['[[maximumFractionDigits]]']);\n\n        // e. If the value of the [[numberingSystem]] internal property of\n        //    numberFormat matches one of the values in the Numbering System column\n        //    of Table 2 below, then\n        if (numSys[nums]) {\n            // i. Let digits be an array whose 10 String valued elements are the\n            //    UTF-16 string representations of the 10 digits specified in the\n            //    Digits column of Table 2 in the row containing the value of the\n            //    [[numberingSystem]] internal property.\n            var digits = numSys[internal['[[numberingSystem]]']];\n            // ii. Replace each digit in n with the value of digits[digit].\n            n = String(n).replace(/\\d/g, function (digit) {\n                return digits[digit];\n            });\n        }\n        // f. Else use an implementation dependent algorithm to map n to the\n        //    appropriate representation of n in the given numbering system.\n        else\n            n = String(n); // ###TODO###\n\n        // g. If n contains the character \".\", then replace it with an ILND String\n        //    representing the decimal separator.\n        n = n.replace(/\\./g, ild.decimal);\n\n        // h. If the value of the [[useGrouping]] internal property of numberFormat\n        //    is true, then insert an ILND String representing a grouping separator\n        //    into an ILND set of locations within the integer part of n.\n        if (internal['[[useGrouping]]'] === true) {\n            var\n                parts  = n.split(ild.decimal),\n                igr    = parts[0],\n\n                // Primary group represents the group closest to the decimal\n                pgSize = data.patterns.primaryGroupSize || 3,\n\n                // Secondary group is every other group\n                sgSize = data.patterns.secondaryGroupSize || pgSize;\n\n            // Group only if necessary\n            if (igr.length > pgSize) {\n                var\n                    groups = new List(),\n\n                    // Index of the primary grouping separator\n                    end    = igr.length - pgSize,\n\n                    // Starting index for our loop\n                    idx    = end % sgSize,\n\n                    start  = igr.slice(0, idx);\n\n                if (start.length)\n                    arrPush.call(groups, start);\n\n                // Loop to separate into secondary grouping digits\n                while (idx < end) {\n                    arrPush.call(groups, igr.slice(idx, idx + sgSize));\n                    idx += sgSize;\n                }\n\n                // Add the primary grouping digits\n                arrPush.call(groups, igr.slice(end));\n\n                parts[0] = arrJoin.call(groups, ild.group);\n            }\n\n            n = arrJoin.call(parts, ild.decimal);\n        }\n    }\n\n    var\n    // 4. If negative is true, then let result be the value of the [[negativePattern]]\n    //    internal property of numberFormat; else let result be the value of the\n    //    [[positivePattern]] internal property of numberFormat.\n        result = internal[negative === true ? '[[negativePattern]]' : '[[positivePattern]]'];\n\n    // 5. Replace the substring \"{number}\" within result with n.\n    result = result.replace('{number}', n);\n\n    // 6. If the value of the [[style]] internal property of numberFormat is\n    //    \"currency\", then:\n    if (internal['[[style]]'] === 'currency') {\n        var cd,\n        // a. Let currency be the value of the [[currency]] internal property of\n        //    numberFormat.\n            currency = internal['[[currency]]'],\n\n        // Shorthand for the currency data\n            cData = data.currencies[currency];\n\n        // b. If the value of the [[currencyDisplay]] internal property of\n        //    numberFormat is \"code\", then let cd be currency.\n        // c. Else if the value of the [[currencyDisplay]] internal property of\n        //    numberFormat is \"symbol\", then let cd be an ILD string representing\n        //    currency in short form. If the implementation does not have such a\n        //    representation of currency, then use currency itself.\n        // d. Else if the value of the [[currencyDisplay]] internal property of\n        //    numberFormat is \"name\", then let cd be an ILD string representing\n        //    currency in long form. If the implementation does not have such a\n        //    representation of currency, then use currency itself.\n        switch (internal['[[currencyDisplay]]']) {\n            case 'symbol':\n                cd = cData || currency;\n                break;\n\n            default:\n            case 'code':\n            case 'name':\n                cd = currency;\n        }\n\n        // e. Replace the substring \"{currency}\" within result with cd.\n        result = result.replace('{currency}', cd);\n    }\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // 7. Return result.\n    return result;\n}\n\n/**\n * When the ToRawPrecision abstract operation is called with arguments x (which\n * must be a finite non-negative number), minPrecision, and maxPrecision (both\n * must be integers between 1 and 21) the following steps are taken:\n */\nfunction ToRawPrecision (x, minPrecision, maxPrecision) {\n    var\n    // 1. Let p be maxPrecision.\n        p = maxPrecision;\n\n    // 2. If x = 0, then\n    if (x === 0) {\n        var\n        // a. Let m be the String consisting of p occurrences of the character \"0\".\n            m = arrJoin.call(Array (p + 1), '0'),\n        // b. Let e be 0.\n            e = 0;\n    }\n    // 3. Else\n    else {\n        // a. Let e and n be integers such that 10  n < 10 and for which the\n        //    exact mathematical value of n  10  x is as close to zero as\n        //    possible. If there are two such sets of e and n, pick the e and n for\n        //    which n  10 is larger.\n        var\n            e = log10Floor(Math.abs(x)),\n\n            // Easier to get to m from here\n            f = Math.round(Math.exp((Math.abs(e - p + 1)) * Math.LN10)),\n\n        // b. Let m be the String consisting of the digits of the decimal\n        //    representation of n (in order, with no leading zeroes)\n            m = String(Math.round(e - p + 1 < 0 ? x * f : x / f));\n    }\n\n    // 4. If e  p, then\n    if (e >= p)\n        // a. Return the concatenation of m and e-p+1 occurrences of the character \"0\".\n        return m + arrJoin.call(Array(e-p+1 + 1), '0');\n\n    // 5. If e = p-1, then\n    else if (e === p - 1)\n        // a. Return m.\n        return m;\n\n    // 6. If e  0, then\n    else if (e >= 0)\n        // a. Let m be the concatenation of the first e+1 characters of m, the character\n        //    \".\", and the remaining p(e+1) characters of m.\n        m = m.slice(0, e + 1) + '.' + m.slice(e + 1);\n\n    // 7. If e < 0, then\n    else if (e < 0)\n        // a. Let m be the concatenation of the String \"0.\", (e+1) occurrences of the\n        //    character \"0\", and the string m.\n        m = '0.' + arrJoin.call(Array (-(e+1) + 1), '0') + m;\n\n    // 8. If m contains the character \".\", and maxPrecision > minPrecision, then\n    if (m.indexOf(\".\") >= 0 && maxPrecision > minPrecision) {\n        var\n        // a. Let cut be maxPrecision  minPrecision.\n            cut = maxPrecision - minPrecision;\n\n        // b. Repeat while cut > 0 and the last character of m is \"0\":\n        while (cut > 0 && m.charAt(m.length-1) === '0') {\n            //  i. Remove the last character from m.\n            m = m.slice(0, -1);\n\n            //  ii. Decrease cut by 1.\n            cut--;\n        }\n\n        // c. If the last character of m is \".\", then\n        if (m.charAt(m.length-1) === '.')\n            //    i. Remove the last character from m.\n            m = m.slice(0, -1);\n    }\n    // 9. Return m.\n    return m;\n}\n\n/**\n * When the ToRawFixed abstract operation is called with arguments x (which must\n * be a finite non-negative number), minInteger (which must be an integer between\n * 1 and 21), minFraction, and maxFraction (which must be integers between 0 and\n * 20) the following steps are taken:\n */\nfunction ToRawFixed (x, minInteger, minFraction, maxFraction) {\n    // (or not because Number.toPrototype.toFixed does a lot of it for us)\n    var idx,\n\n        // We can pick up after the fixed formatted string (m) is created\n        m   = Number.prototype.toFixed.call(x, maxFraction),\n\n        // 4. If [maxFraction]  0, then\n        //    ...\n        //    e. Let int be the number of characters in a.\n        //\n        // 5. Else let int be the number of characters in m.\n        igr = m.split(\".\")[0].length,  // int is a reserved word\n\n        // 6. Let cut be maxFraction  minFraction.\n        cut = maxFraction - minFraction,\n\n        exp = (idx = m.indexOf('e')) > -1 ? m.slice(idx + 1) : 0;\n\n    if (exp) {\n        m = m.slice(0, idx).replace('.', '');\n        m += arrJoin.call(Array(exp - (m.length - 1) + 1), '0')\n          + '.' + arrJoin.call(Array(maxFraction + 1), '0');\n\n        igr = m.length;\n    }\n\n    // 7. Repeat while cut > 0 and the last character of m is \"0\":\n    while (cut > 0 && m.slice(-1) === \"0\") {\n        // a. Remove the last character from m.\n        m = m.slice(0, -1);\n\n        // b. Decrease cut by 1.\n        cut--;\n    }\n\n    // 8. If the last character of m is \".\", then\n    if (m.slice(-1) === \".\")\n        // a. Remove the last character from m.\n        m = m.slice(0, -1);\n\n    // 9. If int < minInteger, then\n    if (igr < minInteger)\n        // a. Let z be the String consisting of minIntegerint occurrences of the\n        //    character \"0\".\n        var z = arrJoin.call(Array(minInteger - igr + 1), '0');\n\n    // 10. Let m be the concatenation of Strings z and m.\n    // 11. Return m.\n    return (z ? z : '') + m;\n}\n\n// Sect 11.3.2 Table 2, Numbering systems\n// ======================================\nvar numSys = {\n    arab:    [ '\\u0660', '\\u0661', '\\u0662', '\\u0663', '\\u0664', '\\u0665', '\\u0666', '\\u0667', '\\u0668', '\\u0669' ],\n    arabext: [ '\\u06F0', '\\u06F1', '\\u06F2', '\\u06F3', '\\u06F4', '\\u06F5', '\\u06F6', '\\u06F7', '\\u06F8', '\\u06F9' ],\n    bali:    [ '\\u1B50', '\\u1B51', '\\u1B52', '\\u1B53', '\\u1B54', '\\u1B55', '\\u1B56', '\\u1B57', '\\u1B58', '\\u1B59' ],\n    beng:    [ '\\u09E6', '\\u09E7', '\\u09E8', '\\u09E9', '\\u09EA', '\\u09EB', '\\u09EC', '\\u09ED', '\\u09EE', '\\u09EF' ],\n    deva:    [ '\\u0966', '\\u0967', '\\u0968', '\\u0969', '\\u096A', '\\u096B', '\\u096C', '\\u096D', '\\u096E', '\\u096F' ],\n    fullwide:[ '\\uFF10', '\\uFF11', '\\uFF12', '\\uFF13', '\\uFF14', '\\uFF15', '\\uFF16', '\\uFF17', '\\uFF18', '\\uFF19' ],\n    gujr:    [ '\\u0AE6', '\\u0AE7', '\\u0AE8', '\\u0AE9', '\\u0AEA', '\\u0AEB', '\\u0AEC', '\\u0AED', '\\u0AEE', '\\u0AEF' ],\n    guru:    [ '\\u0A66', '\\u0A67', '\\u0A68', '\\u0A69', '\\u0A6A', '\\u0A6B', '\\u0A6C', '\\u0A6D', '\\u0A6E', '\\u0A6F' ],\n    hanidec: [ '\\u3007', '\\u4E00', '\\u4E8C', '\\u4E09', '\\u56DB', '\\u4E94', '\\u516D', '\\u4E03', '\\u516B', '\\u4E5D' ],\n    khmr:    [ '\\u17E0', '\\u17E1', '\\u17E2', '\\u17E3', '\\u17E4', '\\u17E5', '\\u17E6', '\\u17E7', '\\u17E8', '\\u17E9' ],\n    knda:    [ '\\u0CE6', '\\u0CE7', '\\u0CE8', '\\u0CE9', '\\u0CEA', '\\u0CEB', '\\u0CEC', '\\u0CED', '\\u0CEE', '\\u0CEF' ],\n    laoo:    [ '\\u0ED0', '\\u0ED1', '\\u0ED2', '\\u0ED3', '\\u0ED4', '\\u0ED5', '\\u0ED6', '\\u0ED7', '\\u0ED8', '\\u0ED9' ],\n    latn:    [ '\\u0030', '\\u0031', '\\u0032', '\\u0033', '\\u0034', '\\u0035', '\\u0036', '\\u0037', '\\u0038', '\\u0039' ],\n    limb:    [ '\\u1946', '\\u1947', '\\u1948', '\\u1949', '\\u194A', '\\u194B', '\\u194C', '\\u194D', '\\u194E', '\\u194F' ],\n    mlym:    [ '\\u0D66', '\\u0D67', '\\u0D68', '\\u0D69', '\\u0D6A', '\\u0D6B', '\\u0D6C', '\\u0D6D', '\\u0D6E', '\\u0D6F' ],\n    mong:    [ '\\u1810', '\\u1811', '\\u1812', '\\u1813', '\\u1814', '\\u1815', '\\u1816', '\\u1817', '\\u1818', '\\u1819' ],\n    mymr:    [ '\\u1040', '\\u1041', '\\u1042', '\\u1043', '\\u1044', '\\u1045', '\\u1046', '\\u1047', '\\u1048', '\\u1049' ],\n    orya:    [ '\\u0B66', '\\u0B67', '\\u0B68', '\\u0B69', '\\u0B6A', '\\u0B6B', '\\u0B6C', '\\u0B6D', '\\u0B6E', '\\u0B6F' ],\n    tamldec: [ '\\u0BE6', '\\u0BE7', '\\u0BE8', '\\u0BE9', '\\u0BEA', '\\u0BEB', '\\u0BEC', '\\u0BED', '\\u0BEE', '\\u0BEF' ],\n    telu:    [ '\\u0C66', '\\u0C67', '\\u0C68', '\\u0C69', '\\u0C6A', '\\u0C6B', '\\u0C6C', '\\u0C6D', '\\u0C6E', '\\u0C6F' ],\n    thai:    [ '\\u0E50', '\\u0E51', '\\u0E52', '\\u0E53', '\\u0E54', '\\u0E55', '\\u0E56', '\\u0E57', '\\u0E58', '\\u0E59' ],\n    tibt:    [ '\\u0F20', '\\u0F21', '\\u0F22', '\\u0F23', '\\u0F24', '\\u0F25', '\\u0F26', '\\u0F27', '\\u0F28', '\\u0F29' ]\n};\n\n/**\n * This function provides access to the locale and formatting options computed\n * during initialization of the object.\n *\n * The function returns a new object whose properties and attributes are set as\n * if constructed by an object literal assigning to each of the following\n * properties the value of the corresponding internal property of this\n * NumberFormat object (see 11.4): locale, numberingSystem, style, currency,\n * currencyDisplay, minimumIntegerDigits, minimumFractionDigits,\n * maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, and\n * useGrouping. Properties whose corresponding internal properties are not present\n * are not assigned.\n */\n/* 11.3.3 */defineProperty(Intl.NumberFormat.prototype, 'resolvedOptions', {\n    configurable: true,\n    writable: true,\n    value: function () {\n        var prop,\n            descs = new Record(),\n            props = [\n                'locale', 'numberingSystem', 'style', 'currency', 'currencyDisplay',\n                'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits',\n                'minimumSignificantDigits', 'maximumSignificantDigits', 'useGrouping'\n            ],\n            internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\n        // Satisfy test 11.3_b\n        if (!internal || !internal['[[initializedNumberFormat]]'])\n            throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.NumberFormat object.');\n\n        for (var i = 0, max = props.length; i < max; i++) {\n            if (hop.call(internal, prop = '[['+ props[i] +']]'))\n                descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n        }\n\n        return objCreate({}, descs);\n    }\n});\n\n// 12.1 The Intl.DateTimeFormat constructor\n// ==================================\n\n// Define the DateTimeFormat constructor internally so it cannot be tainted\nfunction DateTimeFormatConstructor () {\n    var locales = arguments[0];\n    var options = arguments[1];\n\n    if (!this || this === Intl) {\n        return new Intl.DateTimeFormat(locales, options);\n    }\n    return InitializeDateTimeFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'DateTimeFormat', {\n    configurable: true,\n    writable: true,\n    value: DateTimeFormatConstructor\n});\n\n// Must explicitly set prototypes as unwritable\ndefineProperty(DateTimeFormatConstructor, 'prototype', {\n    writable: false\n});\n\n/**\n * The abstract operation InitializeDateTimeFormat accepts the arguments dateTimeFormat\n * (which must be an object), locales, and options. It initializes dateTimeFormat as a\n * DateTimeFormat object.\n */\nfunction/* 12.1.1.1 */InitializeDateTimeFormat (dateTimeFormat, locales, options) {\n    var\n    // This will be a internal properties object if we're not already initialized\n        internal = getInternalProperties(dateTimeFormat),\n\n    // Create an object whose props can be used to restore the values of RegExp props\n        regexpState = createRegExpRestore();\n\n    // 1. If dateTimeFormat has an [[initializedIntlObject]] internal property with\n    //    value true, throw a TypeError exception.\n    if (internal['[[initializedIntlObject]]'] === true)\n        throw new TypeError('`this` object has already been initialized as an Intl object');\n\n    // Need this to access the `internal` object\n    defineProperty(dateTimeFormat, '__getInternalProperties', {\n        value: function () {\n            // NOTE: Non-standard, for internal use only\n            if (arguments[0] === secret)\n                return internal;\n        }\n    });\n\n    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n    internal['[[initializedIntlObject]]'] = true;\n\n    var\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n        requestedLocales = CanonicalizeLocaleList(locales),\n\n    // 4. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined below) with arguments options, \"any\", and \"date\".\n        options = ToDateTimeOptions(options, 'any', 'date'),\n\n    // 5. Let opt be a new Record.\n        opt = new Record();\n\n    // 6. Let matcher be the result of calling the GetOption abstract operation\n    //    (defined in 9.2.9) with arguments options, \"localeMatcher\", \"string\", a List\n    //    containing the two String values \"lookup\" and \"best fit\", and \"best fit\".\n        matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\n    // 7. Set opt.[[localeMatcher]] to matcher.\n    opt['[[localeMatcher]]'] = matcher;\n\n    var\n    // 8. Let DateTimeFormat be the standard built-in object that is the initial\n    //    value of Intl.DateTimeFormat.\n        DateTimeFormat = internals.DateTimeFormat, // This is what we *really* need\n\n    // 9. Let localeData be the value of the [[localeData]] internal property of\n    //    DateTimeFormat.\n        localeData = DateTimeFormat['[[localeData]]'],\n\n    // 10. Let r be the result of calling the ResolveLocale abstract operation\n    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n    //      DateTimeFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n    //      internal property of DateTimeFormat, and localeData.\n        r = ResolveLocale(DateTimeFormat['[[availableLocales]]'], requestedLocales,\n                opt, DateTimeFormat['[[relevantExtensionKeys]]'], localeData);\n\n    // 11. Set the [[locale]] internal property of dateTimeFormat to the value of\n    //     r.[[locale]].\n    internal['[[locale]]'] = r['[[locale]]'];\n\n    // 12. Set the [[calendar]] internal property of dateTimeFormat to the value of\n    //     r.[[ca]].\n    internal['[[calendar]]'] = r['[[ca]]'];\n\n    // 13. Set the [[numberingSystem]] internal property of dateTimeFormat to the value of\n    //     r.[[nu]].\n    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\n    // The specification doesn't tell us to do this, but it's helpful later on\n    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\n    var\n    // 14. Let dataLocale be the value of r.[[dataLocale]].\n        dataLocale = r['[[dataLocale]]'],\n\n    // 15. Let tz be the result of calling the [[Get]] internal method of options with\n    //     argument \"timeZone\".\n        tz = options.timeZone;\n\n    // 16. If tz is not undefined, then\n    if (tz !== undefined) {\n        // a. Let tz be ToString(tz).\n        // b. Convert tz to upper case as described in 6.1.\n        //    NOTE: If an implementation accepts additional time zone values, as permitted\n        //          under certain conditions by the Conformance clause, different casing\n        //          rules apply.\n        tz = toLatinUpperCase(tz);\n\n        // c. If tz is not \"UTC\", then throw a RangeError exception.\n        // ###TODO: accept more time zones###\n        if (tz !== 'UTC')\n            throw new RangeError('timeZone is not supported.');\n    }\n\n    // 17. Set the [[timeZone]] internal property of dateTimeFormat to tz.\n    internal['[[timeZone]]'] = tz;\n\n    // 18. Let opt be a new Record.\n    opt = new Record();\n\n    // 19. For each row of Table 3, except the header row, do:\n    for (var prop in dateTimeComponents) {\n        if (!hop.call(dateTimeComponents, prop))\n            continue;\n\n        var\n        // 20. Let prop be the name given in the Property column of the row.\n        // 21. Let value be the result of calling the GetOption abstract operation,\n        //     passing as argument options, the name given in the Property column of the\n        //     row, \"string\", a List containing the strings given in the Values column of\n        //     the row, and undefined.\n            value = GetOption(options, prop, 'string', dateTimeComponents[prop]);\n\n        // 22. Set opt.[[<prop>]] to value.\n        opt['[['+prop+']]'] = value;\n    }\n\n    var\n        // Assigned a value below\n        bestFormat,\n\n        // 23. Let dataLocaleData be the result of calling the [[Get]] internal method of\n        //     localeData with argument dataLocale.\n        dataLocaleData = localeData[dataLocale],\n\n        // 24. Let formats be the result of calling the [[Get]] internal method of\n        //     dataLocaleData with argument \"formats\".\n        //     Note: we process the CLDR formats into the spec'd structure\n        formats = ToDateTimeFormats(dataLocaleData.formats),\n\n        // 25. Let matcher be the result of calling the GetOption abstract operation with\n        //     arguments options, \"formatMatcher\", \"string\", a List containing the two String\n        //     values \"basic\" and \"best fit\", and \"best fit\".\n        matcher = GetOption(options, 'formatMatcher', 'string', new List('basic', 'best fit'), 'best fit');\n\n    // Optimization: caching the processed formats as a one time operation by\n    // replacing the initial structure from localeData\n    dataLocaleData.formats = formats;\n\n    // 26. If matcher is \"basic\", then\n    if (matcher === 'basic')\n        // 27. Let bestFormat be the result of calling the BasicFormatMatcher abstract\n        //     operation (defined below) with opt and formats.\n        bestFormat = BasicFormatMatcher(opt, formats);\n\n    // 28. Else\n    else\n        // 29. Let bestFormat be the result of calling the BestFitFormatMatcher\n        //     abstract operation (defined below) with opt and formats.\n        bestFormat = BestFitFormatMatcher(opt, formats);\n\n    // 30. For each row in Table 3, except the header row, do\n    for (var prop in dateTimeComponents) {\n        if (!hop.call(dateTimeComponents, prop))\n            continue;\n\n        // a. Let prop be the name given in the Property column of the row.\n        // b. Let pDesc be the result of calling the [[GetOwnProperty]] internal method of\n        //    bestFormat with argument prop.\n        // c. If pDesc is not undefined, then\n        if (hop.call(bestFormat, prop)) {\n            var\n            // i. Let p be the result of calling the [[Get]] internal method of bestFormat\n            //    with argument prop.\n                p = bestFormat[prop];\n\n            // ii. Set the [[<prop>]] internal property of dateTimeFormat to p.\n            internal['[['+prop+']]'] = p;\n        }\n    }\n\n    var\n        // Assigned a value below\n        pattern,\n\n    // 31. Let hr12 be the result of calling the GetOption abstract operation with\n    //     arguments options, \"hour12\", \"boolean\", undefined, and undefined.\n        hr12 = GetOption(options, 'hour12', 'boolean'/*, undefined, undefined*/);\n\n    // 32. If dateTimeFormat has an internal property [[hour]], then\n    if (internal['[[hour]]']) {\n        // a. If hr12 is undefined, then let hr12 be the result of calling the [[Get]]\n        //    internal method of dataLocaleData with argument \"hour12\".\n        hr12 = hr12 === undefined ? dataLocaleData.hour12 : hr12;\n\n        // b. Set the [[hour12]] internal property of dateTimeFormat to hr12.\n        internal['[[hour12]]'] = hr12;\n\n        // c. If hr12 is true, then\n        if (hr12 === true) {\n            var\n            // i. Let hourNo0 be the result of calling the [[Get]] internal method of\n            //    dataLocaleData with argument \"hourNo0\".\n                hourNo0 = dataLocaleData.hourNo0;\n\n            // ii. Set the [[hourNo0]] internal property of dateTimeFormat to hourNo0.\n            internal['[[hourNo0]]'] = hourNo0;\n\n            // iii. Let pattern be the result of calling the [[Get]] internal method of\n            //      bestFormat with argument \"pattern12\".\n            pattern = bestFormat.pattern12;\n        }\n\n        // d. Else\n        else\n            // i. Let pattern be the result of calling the [[Get]] internal method of\n            //    bestFormat with argument \"pattern\".\n            pattern = bestFormat.pattern;\n    }\n\n    // 33. Else\n    else\n        // a. Let pattern be the result of calling the [[Get]] internal method of\n        //    bestFormat with argument \"pattern\".\n        pattern = bestFormat.pattern;\n\n    // 34. Set the [[pattern]] internal property of dateTimeFormat to pattern.\n    internal['[[pattern]]'] = pattern;\n\n    // 35. Set the [[boundFormat]] internal property of dateTimeFormat to undefined.\n    internal['[[boundFormat]]'] = undefined;\n\n    // 36. Set the [[initializedDateTimeFormat]] internal property of dateTimeFormat to\n    //     true.\n    internal['[[initializedDateTimeFormat]]'] = true;\n\n    // In ES3, we need to pre-bind the format() function\n    if (es3)\n        dateTimeFormat.format = GetFormatDateTime.call(dateTimeFormat);\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // Return the newly initialised object\n    return dateTimeFormat;\n}\n\n/**\n * Several DateTimeFormat algorithms use values from the following table, which provides\n * property names and allowable values for the components of date and time formats:\n */\nvar dateTimeComponents = {\n         weekday: [ \"narrow\", \"short\", \"long\" ],\n             era: [ \"narrow\", \"short\", \"long\" ],\n            year: [ \"2-digit\", \"numeric\" ],\n           month: [ \"2-digit\", \"numeric\", \"narrow\", \"short\", \"long\" ],\n             day: [ \"2-digit\", \"numeric\" ],\n            hour: [ \"2-digit\", \"numeric\" ],\n          minute: [ \"2-digit\", \"numeric\" ],\n          second: [ \"2-digit\", \"numeric\" ],\n    timeZoneName: [ \"short\", \"long\" ]\n};\n\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\nfunction ToDateTimeFormats(formats) {\n    if (Object.prototype.toString.call(formats) === '[object Array]') {\n        return formats;\n    }\n    return createDateTimeFormats(formats);\n}\n\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\nfunction ToDateTimeOptions (options, required, defaults) {\n    // 1. If options is undefined, then let options be null, else let options be\n    //    ToObject(options).\n    if (options === undefined)\n        options = null;\n\n    else {\n        // (#12) options needs to be a Record, but it also needs to inherit properties\n        var opt2 = toObject(options);\n        options = new Record();\n\n        for (var k in opt2)\n            options[k] = opt2[k];\n    }\n\n    var\n    // 2. Let create be the standard built-in function object defined in ES5, 15.2.3.5.\n        create = objCreate,\n\n    // 3. Let options be the result of calling the [[Call]] internal method of create with\n    //    undefined as the this value and an argument list containing the single item\n    //    options.\n        options = create(options),\n\n    // 4. Let needDefaults be true.\n        needDefaults = true;\n\n    // 5. If required is \"date\" or \"any\", then\n    if (required === 'date' || required === 'any') {\n        // a. For each of the property names \"weekday\", \"year\", \"month\", \"day\":\n            // i. If the result of calling the [[Get]] internal method of options with the\n            //    property name is not undefined, then let needDefaults be false.\n        if (options.weekday !== undefined || options.year !== undefined\n                || options.month !== undefined || options.day !== undefined)\n            needDefaults = false;\n    }\n\n    // 6. If required is \"time\" or \"any\", then\n    if (required === 'time' || required === 'any') {\n        // a. For each of the property names \"hour\", \"minute\", \"second\":\n            // i. If the result of calling the [[Get]] internal method of options with the\n            //    property name is not undefined, then let needDefaults be false.\n        if (options.hour !== undefined || options.minute !== undefined || options.second !== undefined)\n                needDefaults = false;\n    }\n\n    // 7. If needDefaults is true and defaults is either \"date\" or \"all\", then\n    if (needDefaults && (defaults === 'date' || defaults === 'all'))\n        // a. For each of the property names \"year\", \"month\", \"day\":\n            // i. Call the [[DefineOwnProperty]] internal method of options with the\n            //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n            //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n        options.year = options.month = options.day = 'numeric';\n\n    // 8. If needDefaults is true and defaults is either \"time\" or \"all\", then\n    if (needDefaults && (defaults === 'time' || defaults === 'all'))\n        // a. For each of the property names \"hour\", \"minute\", \"second\":\n            // i. Call the [[DefineOwnProperty]] internal method of options with the\n            //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n            //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n        options.hour = options.minute = options.second = 'numeric';\n\n    // 9. Return options.\n    return options;\n}\n\n/**\n * When the BasicFormatMatcher abstract operation is called with two arguments options and\n * formats, the following steps are taken:\n */\nfunction BasicFormatMatcher (options, formats) {\n    return calculateScore(options, formats);\n}\n\n/**\n * Calculates score for BestFitFormatMatcher and BasicFormatMatcher.\n * Abstracted from BasicFormatMatcher section.\n */\nfunction calculateScore (options, formats, bestFit) {\n    var\n    // Additional penalty type when bestFit === true\n       diffDataTypePenalty = 8,\n\n    // 1. Let removalPenalty be 120.\n        removalPenalty = 120,\n\n    // 2. Let additionPenalty be 20.\n        additionPenalty = 20,\n\n    // 3. Let longLessPenalty be 8.\n        longLessPenalty = 8,\n\n    // 4. Let longMorePenalty be 6.\n        longMorePenalty = 6,\n\n    // 5. Let shortLessPenalty be 6.\n        shortLessPenalty = 6,\n\n    // 6. Let shortMorePenalty be 3.\n        shortMorePenalty = 3,\n\n    // 7. Let bestScore be -Infinity.\n        bestScore = -Infinity,\n\n    // 8. Let bestFormat be undefined.\n        bestFormat,\n\n    // 9. Let i be 0.\n        i = 0,\n\n    // 10. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n        len = formats.length;\n\n    // 11. Repeat while i < len:\n    while (i < len) {\n        var\n        // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n            format = formats[i],\n\n        // b. Let score be 0.\n            score = 0;\n\n        // c. For each property shown in Table 3:\n        for (var property in dateTimeComponents) {\n            if (!hop.call(dateTimeComponents, property))\n                continue;\n\n            var\n            // i. Let optionsProp be options.[[<property>]].\n                optionsProp = options['[['+ property +']]'],\n\n            // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n            //     with argument property.\n            // iii. If formatPropDesc is not undefined, then\n            //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n                formatProp = hop.call(format, property) ? format[property] : undefined;\n\n            // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n            //     additionPenalty.\n            if (optionsProp === undefined && formatProp !== undefined)\n                score -= additionPenalty;\n\n            // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n            //    removalPenalty.\n            else if (optionsProp !== undefined && formatProp === undefined)\n                score -= removalPenalty;\n\n            // vi. Else\n            else {\n                var\n                // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n                //    \"long\"].\n                    values = [ '2-digit', 'numeric', 'narrow', 'short', 'long' ],\n\n                // 2. Let optionsPropIndex be the index of optionsProp within values.\n                    optionsPropIndex = arrIndexOf.call(values, optionsProp),\n\n                // 3. Let formatPropIndex be the index of formatProp within values.\n                    formatPropIndex = arrIndexOf.call(values, formatProp),\n\n                // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n                    delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n\n                // When the bestFit argument is true, subtract additional penalty where data types are not the same\n                if (bestFit && (\n                    ((optionsProp === 'numeric' || optionsProp === '2-digit') && (formatProp !== 'numeric' && formatProp !== '2-digit'))\n                 || ((optionsProp !== 'numeric' && optionsProp !== '2-digit') && (formatProp === '2-digit' || formatProp === 'numeric'))\n                ))\n                    score -= diffDataTypePenalty;\n\n                // 5. If delta = 2, decrease score by longMorePenalty.\n                if (delta === 2)\n                    score -= longMorePenalty;\n\n                // 6. Else if delta = 1, decrease score by shortMorePenalty.\n                else if (delta === 1)\n                    score -= shortMorePenalty;\n\n                // 7. Else if delta = -1, decrease score by shortLessPenalty.\n                else if (delta === -1)\n                    score -= shortLessPenalty;\n\n                // 8. Else if delta = -2, decrease score by longLessPenalty.\n                else if (delta === -2)\n                    score -= longLessPenalty;\n            }\n        }\n\n        // d. If score > bestScore, then\n        if (score > bestScore) {\n            // i. Let bestScore be score.\n            bestScore = score;\n\n            // ii. Let bestFormat be format.\n            bestFormat = format;\n        }\n\n        // e. Increase i by 1.\n        i++;\n    }\n\n    // 12. Return bestFormat.\n    return bestFormat;\n}\n\n/**\n * When the BestFitFormatMatcher abstract operation is called with two arguments options\n * and formats, it performs implementation dependent steps, which should return a set of\n * component representations that a typical user of the selected locale would perceive as\n * at least as good as the one returned by BasicFormatMatcher.\n *\n * This polyfill defines the algorithm to be the same as BasicFormatMatcher,\n * with the addition of bonus points awarded where the requested format is of\n * the same data type as the potentially matching format.\n *\n * For example,\n *\n *     { month: 'numeric', day: 'numeric' }\n *\n * should match\n *\n *     { month: '2-digit', day: '2-digit' }\n *\n * rather than\n *\n *     { month: 'short', day: 'numeric' }\n *\n * This makes sense because a user requesting a formatted date with numeric parts would\n * not expect to see the returned format containing narrow, short or long part names\n */\nfunction BestFitFormatMatcher (options, formats) {\n    return calculateScore(options, formats, true);\n}\n\n/* 12.2.3 */internals.DateTimeFormat = {\n    '[[availableLocales]]': [],\n    '[[relevantExtensionKeys]]': ['ca', 'nu'],\n    '[[localeData]]': {}\n};\n\n/**\n * When the supportedLocalesOf method of Intl.DateTimeFormat is called, the\n * following steps are taken:\n */\n/* 12.2.2 */defineProperty(Intl.DateTimeFormat, 'supportedLocalesOf', {\n    configurable: true,\n    writable: true,\n    value: fnBind.call(supportedLocalesOf, internals.DateTimeFormat)\n});\n\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * DateTimeFormat object.\n */\n/* 12.3.2 */defineProperty(Intl.DateTimeFormat.prototype, 'format', {\n    configurable: true,\n    get: GetFormatDateTime\n});\n\nfunction GetFormatDateTime() {\n    var internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\n    // Satisfy test 12.3_b\n    if (!internal || !internal['[[initializedDateTimeFormat]]'])\n        throw new TypeError('`this` value for format() is not an initialized Intl.DateTimeFormat object.');\n\n    // The value of the [[Get]] attribute is a function that takes the following\n    // steps:\n\n    // 1. If the [[boundFormat]] internal property of this DateTimeFormat object\n    //    is undefined, then:\n    if (internal['[[boundFormat]]'] === undefined) {\n        var\n        // a. Let F be a Function object, with internal properties set as\n        //    specified for built-in functions in ES5, 15, or successor, and the\n        //    length property set to 0, that takes the argument date and\n        //    performs the following steps:\n            F = function () {\n                //   i. If date is not provided or is undefined, then let x be the\n                //      result as if by the expression Date.now() where Date.now is\n                //      the standard built-in function defined in ES5, 15.9.4.4.\n                //  ii. Else let x be ToNumber(date).\n                // iii. Return the result of calling the FormatDateTime abstract\n                //      operation (defined below) with arguments this and x.\n                var x = Number(arguments.length === 0 ? Date.now() : arguments[0]);\n                return FormatDateTime(this, x);\n            },\n        // b. Let bind be the standard built-in function object defined in ES5,\n        //    15.3.4.5.\n        // c. Let bf be the result of calling the [[Call]] internal method of\n        //    bind with F as the this value and an argument list containing\n        //    the single item this.\n            bf = fnBind.call(F, this);\n        // d. Set the [[boundFormat]] internal property of this NumberFormat\n        //    object to bf.\n        internal['[[boundFormat]]'] = bf;\n    }\n    // Return the value of the [[boundFormat]] internal property of this\n    // NumberFormat object.\n    return internal['[[boundFormat]]'];\n}\n\n/**\n * When the FormatDateTime abstract operation is called with arguments dateTimeFormat\n * (which must be an object initialized as a DateTimeFormat) and x (which must be a Number\n * value), it returns a String value representing x (interpreted as a time value as\n * specified in ES5, 15.9.1.1) according to the effective locale and the formatting\n * options of dateTimeFormat.\n */\nfunction FormatDateTime(dateTimeFormat, x) {\n    // 1. If x is not a finite Number, then throw a RangeError exception.\n    if (!isFinite(x))\n        throw new RangeError('Invalid valid date passed to format');\n\n    var\n        internal = dateTimeFormat.__getInternalProperties(secret),\n\n    // Creating restore point for properties on the RegExp object... please wait\n        regexpState = createRegExpRestore(),\n\n    // 2. Let locale be the value of the [[locale]] internal property of dateTimeFormat.\n        locale = internal['[[locale]]'],\n\n    // 3. Let nf be the result of creating a new NumberFormat object as if by the\n    // expression new Intl.NumberFormat([locale], {useGrouping: false}) where\n    // Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n        nf = new Intl.NumberFormat([locale], {useGrouping: false}),\n\n    // 4. Let nf2 be the result of creating a new NumberFormat object as if by the\n    // expression new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping:\n    // false}) where Intl.NumberFormat is the standard built-in constructor defined in\n    // 11.1.3.\n        nf2 = new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping: false}),\n\n    // 5. Let tm be the result of calling the ToLocalTime abstract operation (defined\n    // below) with x, the value of the [[calendar]] internal property of dateTimeFormat,\n    // and the value of the [[timeZone]] internal property of dateTimeFormat.\n        tm = ToLocalTime(x, internal['[[calendar]]'], internal['[[timeZone]]']),\n\n    // 6. Let result be the value of the [[pattern]] internal property of dateTimeFormat.\n        result = internal['[[pattern]]'],\n\n    // Need the locale minus any extensions\n        dataLocale = internal['[[dataLocale]]'],\n\n    // Need the calendar data from CLDR\n        localeData = internals.DateTimeFormat['[[localeData]]'][dataLocale].calendars,\n        ca = internal['[[calendar]]'];\n\n    // 7. For each row of Table 3, except the header row, do:\n    for (var p in dateTimeComponents) {\n        // a. If dateTimeFormat has an internal property with the name given in the\n        //    Property column of the row, then:\n        if (hop.call(internal, '[['+ p +']]')) {\n            var\n            // Assigned values below\n                pm, fv,\n\n            //   i. Let p be the name given in the Property column of the row.\n            //  ii. Let f be the value of the [[<p>]] internal property of dateTimeFormat.\n                f = internal['[['+ p +']]'],\n\n            // iii. Let v be the value of tm.[[<p>]].\n                v = tm['[['+ p +']]'];\n\n            //  iv. If p is \"year\" and v  0, then let v be 1 - v.\n            if (p === 'year' && v <= 0)\n                v = 1 - v;\n\n            //   v. If p is \"month\", then increase v by 1.\n            else if (p === 'month')\n                v++;\n\n            //  vi. If p is \"hour\" and the value of the [[hour12]] internal property of\n            //      dateTimeFormat is true, then\n            else if (p === 'hour' && internal['[[hour12]]'] === true) {\n                // 1. Let v be v modulo 12.\n                v = v % 12;\n\n                // 2. If v is equal to the value of tm.[[<p>]], then let pm be false; else\n                //    let pm be true.\n                pm = v !== tm['[['+ p +']]'];\n\n                // 3. If v is 0 and the value of the [[hourNo0]] internal property of\n                //    dateTimeFormat is true, then let v be 12.\n                if (v === 0 && internal['[[hourNo0]]'] === true)\n                    v = 12;\n            }\n\n            // vii. If f is \"numeric\", then\n            if (f === 'numeric')\n                // 1. Let fv be the result of calling the FormatNumber abstract operation\n                //    (defined in 11.3.2) with arguments nf and v.\n                fv = FormatNumber(nf, v);\n\n            // viii. Else if f is \"2-digit\", then\n            else if (f === '2-digit') {\n                // 1. Let fv be the result of calling the FormatNumber abstract operation\n                //    with arguments nf2 and v.\n                fv = FormatNumber(nf2, v);\n\n                // 2. If the length of fv is greater than 2, let fv be the substring of fv\n                //    containing the last two characters.\n                if (fv.length > 2)\n                    fv = fv.slice(-2);\n            }\n\n            // ix. Else if f is \"narrow\", \"short\", or \"long\", then let fv be a String\n            //     value representing f in the desired form; the String value depends upon\n            //     the implementation and the effective locale and calendar of\n            //     dateTimeFormat. If p is \"month\", then the String value may also depend\n            //     on whether dateTimeFormat has a [[day]] internal property. If p is\n            //     \"timeZoneName\", then the String value may also depend on the value of\n            //     the [[inDST]] field of tm.\n            else if (f in dateWidths) {\n                switch (p) {\n                    case 'month':\n                        fv = resolveDateString(localeData, ca, 'months', f, tm['[['+ p +']]']);\n                        break;\n\n                    case 'weekday':\n                        try {\n                            fv = resolveDateString(localeData, ca, 'days', f, tm['[['+ p +']]']);\n                            // fv = resolveDateString(ca.days, f)[tm['[['+ p +']]']];\n                        } catch (e) {\n                            throw new Error('Could not find weekday data for locale '+locale);\n                        }\n                        break;\n\n                    case 'timeZoneName':\n                        fv = ''; // TODO\n                        break;\n\n                    // TODO: Era\n                    default:\n                        fv = tm['[['+ p +']]'];\n                }\n            }\n\n            // x. Replace the substring of result that consists of \"{\", p, and \"}\", with\n            //    fv.\n            result = result.replace('{'+ p +'}', fv);\n        }\n    }\n    // 8. If dateTimeFormat has an internal property [[hour12]] whose value is true, then\n    if (internal['[[hour12]]'] === true) {\n        // a. If pm is true, then let fv be an implementation and locale dependent String\n        //    value representing post meridiem; else let fv be an implementation and\n        //    locale dependent String value representing ante meridiem.\n        fv = resolveDateString(localeData, ca, 'dayPeriods', pm ? 'pm' : 'am');\n\n        // b. Replace the substring of result that consists of \"{ampm}\", with fv.\n        result = result.replace('{ampm}', fv);\n    }\n\n    // Restore properties of the RegExp object\n    regexpState.exp.test(regexpState.input);\n\n    // 9. Return result.\n    return result;\n}\n\n/**\n * When the ToLocalTime abstract operation is called with arguments date, calendar, and\n * timeZone, the following steps are taken:\n */\nfunction ToLocalTime(date, calendar, timeZone) {\n    // 1. Apply calendrical calculations on date for the given calendar and time zone to\n    //    produce weekday, era, year, month, day, hour, minute, second, and inDST values.\n    //    The calculations should use best available information about the specified\n    //    calendar and time zone. If the calendar is \"gregory\", then the calculations must\n    //    match the algorithms specified in ES5, 15.9.1, except that calculations are not\n    //    bound by the restrictions on the use of best available information on time zones\n    //    for local time zone adjustment and daylight saving time adjustment imposed by\n    //    ES5, 15.9.1.7 and 15.9.1.8.\n    // ###TODO###\n    var d = new Date(date),\n        m = 'get' + (timeZone || '');\n\n    // 2. Return a Record with fields [[weekday]], [[era]], [[year]], [[month]], [[day]],\n    //    [[hour]], [[minute]], [[second]], and [[inDST]], each with the corresponding\n    //    calculated value.\n    return new Record({\n        '[[weekday]]': d[m + 'Day'](),\n        '[[era]]'    : +(d[m + 'FullYear']() >= 0),\n        '[[year]]'   : d[m + 'FullYear'](),\n        '[[month]]'  : d[m + 'Month'](),\n        '[[day]]'    : d[m + 'Date'](),\n        '[[hour]]'   : d[m + 'Hours'](),\n        '[[minute]]' : d[m + 'Minutes'](),\n        '[[second]]' : d[m + 'Seconds'](),\n        '[[inDST]]'  : false // ###TODO###\n    });\n}\n\n/**\n * The function returns a new object whose properties and attributes are set as if\n * constructed by an object literal assigning to each of the following properties the\n * value of the corresponding internal property of this DateTimeFormat object (see 12.4):\n * locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day,\n * hour, minute, second, and timeZoneName. Properties whose corresponding internal\n * properties are not present are not assigned.\n */\n/* 12.3.3 */defineProperty(Intl.DateTimeFormat.prototype, 'resolvedOptions', {\n    writable: true,\n    configurable: true,\n    value: function () {\n        var prop,\n            descs = new Record(),\n            props = [\n                'locale', 'calendar', 'numberingSystem', 'timeZone', 'hour12', 'weekday',\n                'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName'\n            ],\n            internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\n        // Satisfy test 12.3_b\n        if (!internal || !internal['[[initializedDateTimeFormat]]'])\n            throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.DateTimeFormat object.');\n\n        for (var i = 0, max = props.length; i < max; i++) {\n            if (hop.call(internal, prop = '[[' + props[i] + ']]'))\n                descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n        }\n\n        return objCreate({}, descs);\n    }\n});\n\n// Sect 13 Locale Sensitive Functions of the ECMAScript Language Specification\n// ===========================================================================\n\nvar ls = Intl.__localeSensitiveProtos = {\n    Number: {},\n    Date:   {}\n};\n\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n/* 13.2.1 */ls.Number.toLocaleString = function () {\n    // Satisfy test 13.2.1_1\n    if (Object.prototype.toString.call(this) !== '[object Number]')\n        throw new TypeError('`this` value must be a number for Number.prototype.toLocaleString()');\n\n    // 1. Let x be this Number value (as defined in ES5, 15.7.4).\n    // 2. If locales is not provided, then let locales be undefined.\n    // 3. If options is not provided, then let options be undefined.\n    // 4. Let numberFormat be the result of creating a new object as if by the\n    //    expression new Intl.NumberFormat(locales, options) where\n    //    Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n    // 5. Return the result of calling the FormatNumber abstract operation\n    //    (defined in 11.3.2) with arguments numberFormat and x.\n    return FormatNumber(new NumberFormatConstructor(arguments[0], arguments[1]), this);\n};\n\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n/* 13.3.1 */ls.Date.toLocaleString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]')\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleString()');\n\n    var\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n        x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x))\n        return 'Invalid Date';\n\n    var\n    // 3. If locales is not provided, then let locales be undefined.\n        locales = arguments[0],\n\n    // 4. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"any\", and \"all\".\n        options = ToDateTimeOptions(options, 'any', 'all'),\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n        dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\n/**\n * When the toLocaleDateString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n/* 13.3.2 */ls.Date.toLocaleDateString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]')\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleDateString()');\n\n    var\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n        x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x))\n        return 'Invalid Date';\n\n    var\n    // 3. If locales is not provided, then let locales be undefined.\n        locales = arguments[0],\n\n    // 4. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"date\", and \"date\".\n        options = ToDateTimeOptions(options, 'date', 'date'),\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n        dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\n/**\n * When the toLocaleTimeString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n/* 13.3.3 */ls.Date.toLocaleTimeString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]')\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleTimeString()');\n\n    var\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n        x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x))\n        return 'Invalid Date';\n\n    var\n    // 3. If locales is not provided, then let locales be undefined.\n        locales = arguments[0],\n\n    // 4. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"time\", and \"time\".\n        options = ToDateTimeOptions(options, 'time', 'time'),\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n        dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\ndefineProperty(Intl, '__applyLocaleSensitivePrototypes', {\n    writable: true,\n    configurable: true,\n    value: function () {\n        defineProperty(Number.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Number.toLocaleString });\n        // Need this here for IE 8, to avoid the _DontEnum_ bug\n        defineProperty(Date.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Date.toLocaleString });\n\n        for (var k in ls.Date) {\n            if (hop.call(ls.Date, k))\n                defineProperty(Date.prototype, k, { writable: true, configurable: true, value: ls.Date[k] });\n        }\n    }\n});\n\n/**\n * Can't really ship a single script with data for hundreds of locales, so we provide\n * this __addLocaleData method as a means for the developer to add the data on an\n * as-needed basis\n */\ndefineProperty(Intl, '__addLocaleData', {\n    value: function (data) {\n        if (!IsStructurallyValidLanguageTag(data.locale))\n            throw new Error(\"Object passed doesn't identify itself with a valid language tag\");\n\n        addLocaleData(data, data.locale);\n    }\n});\n\nfunction addLocaleData (data, tag) {\n    // Both NumberFormat and DateTimeFormat require number data, so throw if it isn't present\n    if (!data.number)\n        throw new Error(\"Object passed doesn't contain locale data for Intl.NumberFormat\");\n\n    var locale,\n        locales = [ tag ],\n        parts   = tag.split('-');\n\n    // Create fallbacks for locale data with scripts, e.g. Latn, Hans, Vaii, etc\n    if (parts.length > 2 && parts[1].length === 4)\n        arrPush.call(locales, parts[0] + '-' + parts[2]);\n\n    while (locale = arrShift.call(locales)) {\n        // Add to NumberFormat internal properties as per 11.2.3\n        arrPush.call(internals.NumberFormat['[[availableLocales]]'], locale);\n        internals.NumberFormat['[[localeData]]'][locale] = data.number;\n\n        // ...and DateTimeFormat internal properties as per 12.2.3\n        if (data.date) {\n            data.date.nu = data.number.nu;\n            arrPush.call(internals.DateTimeFormat['[[availableLocales]]'], locale);\n            internals.DateTimeFormat['[[localeData]]'][locale] = data.date;\n        }\n    }\n\n    // If this is the first set of locale data added, make it the default\n    if (defaultLocale === undefined)\n        defaultLocale = tag;\n\n    // 11.3 (the NumberFormat prototype object is an Intl.NumberFormat instance)\n    if (!numberFormatProtoInitialised) {\n        InitializeNumberFormat(Intl.NumberFormat.prototype);\n        numberFormatProtoInitialised = true;\n    }\n\n    // 11.3 (the NumberFormat prototype object is an Intl.NumberFormat instance)\n    if (data.date && !dateTimeFormatProtoInitialised) {\n        InitializeDateTimeFormat(Intl.DateTimeFormat.prototype);\n        dateTimeFormatProtoInitialised = true;\n    }\n}\n\n// Helper functions\n// ================\n\n/**\n * A function to deal with the inaccuracy of calculating log10 in pre-ES6\n * JavaScript environments. Math.log(num) / Math.LN10 was responsible for\n * causing issue #62.\n */\nfunction log10Floor (n) {\n    // ES6 provides the more accurate Math.log10\n    if (typeof Math.log10 === 'function')\n        return Math.floor(Math.log10(n));\n\n    var x = Math.round(Math.log(n) * Math.LOG10E);\n    return x - (Number('1e' + x) > n);\n}\n\n/**\n * A merge of the Intl.{Constructor}.supportedLocalesOf functions\n * To make life easier, the function should be bound to the constructor's internal\n * properties object.\n */\nfunction supportedLocalesOf(locales) {\n    /*jshint validthis:true */\n\n    // Bound functions only have the `this` value altered if being used as a constructor,\n    // this lets us imitate a native function that has no constructor\n    if (!hop.call(this, '[[availableLocales]]'))\n        throw new TypeError('supportedLocalesOf() is not a constructor');\n\n    var\n    // Create an object whose props can be used to restore the values of RegExp props\n        regexpState = createRegExpRestore(),\n\n    // 1. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n    // 2. Let availableLocales be the value of the [[availableLocales]] internal\n    //    property of the standard built-in object that is the initial value of\n    //    Intl.NumberFormat.\n\n        availableLocales = this['[[availableLocales]]'],\n\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n        requestedLocales = CanonicalizeLocaleList(locales);\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // 4. Return the result of calling the SupportedLocales abstract operation\n    //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n    //    and options.\n    return SupportedLocales(availableLocales, requestedLocales, options);\n}\n\n/**\n * Returns a string for a date component, resolved using multiple inheritance as specified\n * as specified in the Unicode Technical Standard 35.\n */\nfunction resolveDateString(data, ca, component, width, key) {\n    // From http://www.unicode.org/reports/tr35/tr35.html#Multiple_Inheritance:\n    // 'In clearly specified instances, resources may inherit from within the same locale.\n    //  For example, ... the Buddhist calendar inherits from the Gregorian calendar.'\n    var obj = data[ca] && data[ca][component]\n                ? data[ca][component]\n                : data.gregory[component],\n\n        // \"sideways\" inheritance resolves strings when a key doesn't exist\n        alts = {\n            narrow: ['short', 'long'],\n            short:  ['long', 'narrow'],\n            long:   ['short', 'narrow']\n        },\n\n        //\n        resolved = hop.call(obj, width)\n                  ? obj[width]\n                  : hop.call(obj, alts[width][0])\n                      ? obj[alts[width][0]]\n                      : obj[alts[width][1]];\n\n    // `key` wouldn't be specified for components 'dayPeriods'\n    return key != null ? resolved[key] : resolved;\n}\n\n/**\n * A map that doesn't contain Object in its prototype chain\n */\nRecord.prototype = objCreate(null);\nfunction Record (obj) {\n    // Copy only own properties over unless this object is already a Record instance\n    for (var k in obj) {\n        if (obj instanceof Record || hop.call(obj, k))\n            defineProperty(this, k, { value: obj[k], enumerable: true, writable: true, configurable: true });\n    }\n}\n\n/**\n * An ordered list\n */\nList.prototype = objCreate(null);\nfunction List() {\n    defineProperty(this, 'length', { writable:true, value: 0 });\n\n    if (arguments.length)\n        arrPush.apply(this, arrSlice.call(arguments));\n}\n\n/**\n * Constructs a regular expression to restore tainted RegExp properties\n */\nfunction createRegExpRestore () {\n    var esc = /[.?*+^$[\\]\\\\(){}|-]/g,\n        lm  = RegExp.lastMatch || '',\n        ml  = RegExp.multiline ? 'm' : '',\n        ret = { input: RegExp.input },\n        reg = new List(),\n        has = false,\n        cap = {};\n\n    // Create a snapshot of all the 'captured' properties\n    for (var i = 1; i <= 9; i++)\n        has = (cap['$'+i] = RegExp['$'+i]) || has;\n\n    // Now we've snapshotted some properties, escape the lastMatch string\n    lm = lm.replace(esc, '\\\\$&');\n\n    // If any of the captured strings were non-empty, iterate over them all\n    if (has) {\n        for (var i = 1; i <= 9; i++) {\n            var m = cap['$'+i];\n\n            // If it's empty, add an empty capturing group\n            if (!m)\n                lm = '()' + lm;\n\n            // Else find the string in lm and escape & wrap it to capture it\n            else {\n                m = m.replace(esc, '\\\\$&');\n                lm = lm.replace(m, '(' + m + ')');\n            }\n\n            // Push it to the reg and chop lm to make sure further groups come after\n            arrPush.call(reg, lm.slice(0, lm.indexOf('(') + 1));\n            lm = lm.slice(lm.indexOf('(') + 1);\n        }\n    }\n\n    // Create the regular expression that will reconstruct the RegExp properties\n    ret.exp = new RegExp(arrJoin.call(reg, '') + lm, ml);\n\n    return ret;\n}\n\n/**\n * Convert only a-z to uppercase as per section 6.1 of the spec\n */\nfunction toLatinUpperCase (str) {\n    var i = str.length;\n\n    while (i--) {\n        var ch = str.charAt(i);\n\n        if (ch >= \"a\" && ch <= \"z\")\n            str = str.slice(0, i) + ch.toUpperCase() + str.slice(i+1);\n    }\n\n    return str;\n}\n\n/**\n * Mimics ES5's abstract ToObject() function\n */\nfunction toObject (arg) {\n    if (arg == null)\n        throw new TypeError('Cannot convert null or undefined to object');\n\n    return Object(arg);\n}\n\n/**\n * Returns \"internal\" properties for an object\n */\nfunction getInternalProperties (obj) {\n    if (hop.call(obj, '__getInternalProperties'))\n        return obj.__getInternalProperties(secret);\n    else\n        return objCreate(null);\n}\n\nexport default Intl;\n","/* jslint esnext: true */\n\nimport IntlPolyfill from \"./core\";\n\n// hack to export the polyfill as global Intl if needed\nif (!this.Intl) {\n    this.Intl = IntlPolyfill;\n    IntlPolyfill.__applyLocaleSensitivePrototypes();\n}\n\nexport default IntlPolyfill;\n"]}